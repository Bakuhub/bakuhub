# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregatePremise {
  _count: PremiseCountAggregate
  _max: PremiseMaxAggregate
  _min: PremiseMinAggregate
}

type AggregatePremisesOnTimelines {
  _count: PremisesOnTimelinesCountAggregate
  _max: PremisesOnTimelinesMaxAggregate
  _min: PremisesOnTimelinesMinAggregate
}

type AggregateSnapshot {
  _count: SnapshotCountAggregate
  _max: SnapshotMaxAggregate
  _min: SnapshotMinAggregate
}

type AggregateTag {
  _avg: TagAvgAggregate
  _count: TagCountAggregate
  _max: TagMaxAggregate
  _min: TagMinAggregate
  _sum: TagSumAggregate
}

type AggregateTagsOnPremises {
  _avg: TagsOnPremisesAvgAggregate
  _count: TagsOnPremisesCountAggregate
  _max: TagsOnPremisesMaxAggregate
  _min: TagsOnPremisesMinAggregate
  _sum: TagsOnPremisesSumAggregate
}

type AggregateTagsOnTimelines {
  _avg: TagsOnTimelinesAvgAggregate
  _count: TagsOnTimelinesCountAggregate
  _max: TagsOnTimelinesMaxAggregate
  _min: TagsOnTimelinesMinAggregate
  _sum: TagsOnTimelinesSumAggregate
}

type AggregateThread {
  _count: ThreadCountAggregate
  _max: ThreadMaxAggregate
  _min: ThreadMinAggregate
}

type AggregateTimeline {
  _count: TimelineCountAggregate
  _max: TimelineMaxAggregate
  _min: TimelineMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type AggregateVision {
  _count: VisionCountAggregate
  _max: VisionMaxAggregate
  _min: VisionMinAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumPremiseStatusFieldUpdateOperationsInput {
  set: PremiseStatus
}

input EnumPremiseStatusFilter {
  equals: PremiseStatus
  in: [PremiseStatus!]
  not: NestedEnumPremiseStatusFilter
  notIn: [PremiseStatus!]
}

input EnumPremiseStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumPremiseStatusFilter
  _min: NestedEnumPremiseStatusFilter
  equals: PremiseStatus
  in: [PremiseStatus!]
  not: NestedEnumPremiseStatusWithAggregatesFilter
  notIn: [PremiseStatus!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyPremise(data: [PremiseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPremisesOnTimelines(data: [PremisesOnTimelinesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySnapshot(data: [SnapshotCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTag(data: [TagCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTagsOnPremises(data: [TagsOnPremisesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTagsOnTimelines(data: [TagsOnTimelinesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyThread(data: [ThreadCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTimeline(data: [TimelineCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyVision(data: [VisionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createPremise(data: PremiseCreateInput!): Premise!
  createPremisesOnTimelines(data: PremisesOnTimelinesCreateInput!): PremisesOnTimelines!
  createSnapshot(data: SnapshotCreateInput!): Snapshot!
  createTag(data: TagCreateInput!): Tag!
  createTagsOnPremises(data: TagsOnPremisesCreateInput!): TagsOnPremises!
  createTagsOnTimelines(data: TagsOnTimelinesCreateInput!): TagsOnTimelines!
  createThread(data: ThreadCreateInput!): Thread!
  createTimeline(data: TimelineCreateInput!): Timeline!
  createUser(data: UserCreateInput!): User!
  createVision(data: VisionCreateInput!): Vision!
  deleteManyPremise(where: PremiseWhereInput): AffectedRowsOutput!
  deleteManyPremisesOnTimelines(where: PremisesOnTimelinesWhereInput): AffectedRowsOutput!
  deleteManySnapshot(where: SnapshotWhereInput): AffectedRowsOutput!
  deleteManyTag(where: TagWhereInput): AffectedRowsOutput!
  deleteManyTagsOnPremises(where: TagsOnPremisesWhereInput): AffectedRowsOutput!
  deleteManyTagsOnTimelines(where: TagsOnTimelinesWhereInput): AffectedRowsOutput!
  deleteManyThread(where: ThreadWhereInput): AffectedRowsOutput!
  deleteManyTimeline(where: TimelineWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyVision(where: VisionWhereInput): AffectedRowsOutput!
  deletePremise(where: PremiseWhereUniqueInput!): Premise
  deletePremisesOnTimelines(where: PremisesOnTimelinesWhereUniqueInput!): PremisesOnTimelines
  deleteSnapshot(where: SnapshotWhereUniqueInput!): Snapshot
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteTagsOnPremises(where: TagsOnPremisesWhereUniqueInput!): TagsOnPremises
  deleteTagsOnTimelines(where: TagsOnTimelinesWhereUniqueInput!): TagsOnTimelines
  deleteThread(where: ThreadWhereUniqueInput!): Thread
  deleteTimeline(where: TimelineWhereUniqueInput!): Timeline
  deleteUser(where: UserWhereUniqueInput!): User
  deleteVision(where: VisionWhereUniqueInput!): Vision
  updateManyPremise(data: PremiseUpdateManyMutationInput!, where: PremiseWhereInput): AffectedRowsOutput!
  updateManyPremisesOnTimelines(data: PremisesOnTimelinesUpdateManyMutationInput!, where: PremisesOnTimelinesWhereInput): AffectedRowsOutput!
  updateManySnapshot(data: SnapshotUpdateManyMutationInput!, where: SnapshotWhereInput): AffectedRowsOutput!
  updateManyTag(data: TagUpdateManyMutationInput!, where: TagWhereInput): AffectedRowsOutput!
  updateManyTagsOnPremises(data: TagsOnPremisesUpdateManyMutationInput!, where: TagsOnPremisesWhereInput): AffectedRowsOutput!
  updateManyTagsOnTimelines(data: TagsOnTimelinesUpdateManyMutationInput!, where: TagsOnTimelinesWhereInput): AffectedRowsOutput!
  updateManyThread(data: ThreadUpdateManyMutationInput!, where: ThreadWhereInput): AffectedRowsOutput!
  updateManyTimeline(data: TimelineUpdateManyMutationInput!, where: TimelineWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyVision(data: VisionUpdateManyMutationInput!, where: VisionWhereInput): AffectedRowsOutput!
  updatePremise(data: PremiseUpdateInput!, where: PremiseWhereUniqueInput!): Premise
  updatePremisesOnTimelines(data: PremisesOnTimelinesUpdateInput!, where: PremisesOnTimelinesWhereUniqueInput!): PremisesOnTimelines
  updateSnapshot(data: SnapshotUpdateInput!, where: SnapshotWhereUniqueInput!): Snapshot
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateTagsOnPremises(data: TagsOnPremisesUpdateInput!, where: TagsOnPremisesWhereUniqueInput!): TagsOnPremises
  updateTagsOnTimelines(data: TagsOnTimelinesUpdateInput!, where: TagsOnTimelinesWhereUniqueInput!): TagsOnTimelines
  updateThread(data: ThreadUpdateInput!, where: ThreadWhereUniqueInput!): Thread
  updateTimeline(data: TimelineUpdateInput!, where: TimelineWhereUniqueInput!): Timeline
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateVision(data: VisionUpdateInput!, where: VisionWhereUniqueInput!): Vision
  upsertPremise(create: PremiseCreateInput!, update: PremiseUpdateInput!, where: PremiseWhereUniqueInput!): Premise!
  upsertPremisesOnTimelines(create: PremisesOnTimelinesCreateInput!, update: PremisesOnTimelinesUpdateInput!, where: PremisesOnTimelinesWhereUniqueInput!): PremisesOnTimelines!
  upsertSnapshot(create: SnapshotCreateInput!, update: SnapshotUpdateInput!, where: SnapshotWhereUniqueInput!): Snapshot!
  upsertTag(create: TagCreateInput!, update: TagUpdateInput!, where: TagWhereUniqueInput!): Tag!
  upsertTagsOnPremises(create: TagsOnPremisesCreateInput!, update: TagsOnPremisesUpdateInput!, where: TagsOnPremisesWhereUniqueInput!): TagsOnPremises!
  upsertTagsOnTimelines(create: TagsOnTimelinesCreateInput!, update: TagsOnTimelinesUpdateInput!, where: TagsOnTimelinesWhereUniqueInput!): TagsOnTimelines!
  upsertThread(create: ThreadCreateInput!, update: ThreadUpdateInput!, where: ThreadWhereUniqueInput!): Thread!
  upsertTimeline(create: TimelineCreateInput!, update: TimelineUpdateInput!, where: TimelineWhereUniqueInput!): Timeline!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertVision(create: VisionCreateInput!, update: VisionUpdateInput!, where: VisionWhereUniqueInput!): Vision!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumPremiseStatusFilter {
  equals: PremiseStatus
  in: [PremiseStatus!]
  not: NestedEnumPremiseStatusFilter
  notIn: [PremiseStatus!]
}

input NestedEnumPremiseStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumPremiseStatusFilter
  _min: NestedEnumPremiseStatusFilter
  equals: PremiseStatus
  in: [PremiseStatus!]
  not: NestedEnumPremiseStatusWithAggregatesFilter
  notIn: [PremiseStatus!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Premise {
  _count: PremiseCount
  author: User
  authorId: String
  createdAt: DateTime!
  id: String!
  premisesOnTimelines(cursor: PremisesOnTimelinesWhereUniqueInput, distinct: [PremisesOnTimelinesScalarFieldEnum!], orderBy: [PremisesOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: PremisesOnTimelinesWhereInput): [PremisesOnTimelines!]!
  status: PremiseStatus!
  tagsOnPremises(cursor: TagsOnPremisesWhereUniqueInput, distinct: [TagsOnPremisesScalarFieldEnum!], orderBy: [TagsOnPremisesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnPremisesWhereInput): [TagsOnPremises!]!
  thread(cursor: ThreadWhereUniqueInput, distinct: [ThreadScalarFieldEnum!], orderBy: [ThreadOrderByWithRelationInput!], skip: Int, take: Int, where: ThreadWhereInput): [Thread!]!
  title: String!
  updatedAt: DateTime!
  vision(cursor: VisionWhereUniqueInput, distinct: [VisionScalarFieldEnum!], orderBy: [VisionOrderByWithRelationInput!], skip: Int, take: Int, where: VisionWhereInput): [Vision!]!
}

type PremiseCount {
  premisesOnTimelines: Int!
  tagsOnPremises: Int!
  thread: Int!
  vision: Int!
}

type PremiseCountAggregate {
  _all: Int!
  authorId: Int!
  createdAt: Int!
  id: Int!
  status: Int!
  title: Int!
  updatedAt: Int!
}

input PremiseCountOrderByAggregateInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  status: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input PremiseCreateInput {
  author: UserCreateNestedOneWithoutPremiseInput
  createdAt: DateTime
  id: String
  premisesOnTimelines: PremisesOnTimelinesCreateNestedManyWithoutPremiseInput
  status: PremiseStatus!
  tagsOnPremises: TagsOnPremisesCreateNestedManyWithoutPremiseInput
  thread: ThreadCreateNestedManyWithoutPremiseInput
  title: String!
  updatedAt: DateTime
  vision: VisionCreateNestedManyWithoutPremiseInput
}

input PremiseCreateManyAuthorInput {
  createdAt: DateTime
  id: String
  status: PremiseStatus!
  title: String!
  updatedAt: DateTime
}

input PremiseCreateManyAuthorInputEnvelope {
  data: [PremiseCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input PremiseCreateManyInput {
  authorId: String
  createdAt: DateTime
  id: String
  status: PremiseStatus!
  title: String!
  updatedAt: DateTime
}

input PremiseCreateNestedManyWithoutAuthorInput {
  connect: [PremiseWhereUniqueInput!]
  connectOrCreate: [PremiseCreateOrConnectWithoutAuthorInput!]
  create: [PremiseCreateWithoutAuthorInput!]
  createMany: PremiseCreateManyAuthorInputEnvelope
}

input PremiseCreateNestedOneWithoutPremisesOnTimelinesInput {
  connect: PremiseWhereUniqueInput
  connectOrCreate: PremiseCreateOrConnectWithoutPremisesOnTimelinesInput
  create: PremiseCreateWithoutPremisesOnTimelinesInput
}

input PremiseCreateNestedOneWithoutTagsOnPremisesInput {
  connect: PremiseWhereUniqueInput
  connectOrCreate: PremiseCreateOrConnectWithoutTagsOnPremisesInput
  create: PremiseCreateWithoutTagsOnPremisesInput
}

input PremiseCreateNestedOneWithoutThreadInput {
  connect: PremiseWhereUniqueInput
  connectOrCreate: PremiseCreateOrConnectWithoutThreadInput
  create: PremiseCreateWithoutThreadInput
}

input PremiseCreateNestedOneWithoutVisionInput {
  connect: PremiseWhereUniqueInput
  connectOrCreate: PremiseCreateOrConnectWithoutVisionInput
  create: PremiseCreateWithoutVisionInput
}

input PremiseCreateOrConnectWithoutAuthorInput {
  create: PremiseCreateWithoutAuthorInput!
  where: PremiseWhereUniqueInput!
}

input PremiseCreateOrConnectWithoutPremisesOnTimelinesInput {
  create: PremiseCreateWithoutPremisesOnTimelinesInput!
  where: PremiseWhereUniqueInput!
}

input PremiseCreateOrConnectWithoutTagsOnPremisesInput {
  create: PremiseCreateWithoutTagsOnPremisesInput!
  where: PremiseWhereUniqueInput!
}

input PremiseCreateOrConnectWithoutThreadInput {
  create: PremiseCreateWithoutThreadInput!
  where: PremiseWhereUniqueInput!
}

input PremiseCreateOrConnectWithoutVisionInput {
  create: PremiseCreateWithoutVisionInput!
  where: PremiseWhereUniqueInput!
}

input PremiseCreateWithoutAuthorInput {
  createdAt: DateTime
  id: String
  premisesOnTimelines: PremisesOnTimelinesCreateNestedManyWithoutPremiseInput
  status: PremiseStatus!
  tagsOnPremises: TagsOnPremisesCreateNestedManyWithoutPremiseInput
  thread: ThreadCreateNestedManyWithoutPremiseInput
  title: String!
  updatedAt: DateTime
  vision: VisionCreateNestedManyWithoutPremiseInput
}

input PremiseCreateWithoutPremisesOnTimelinesInput {
  author: UserCreateNestedOneWithoutPremiseInput
  createdAt: DateTime
  id: String
  status: PremiseStatus!
  tagsOnPremises: TagsOnPremisesCreateNestedManyWithoutPremiseInput
  thread: ThreadCreateNestedManyWithoutPremiseInput
  title: String!
  updatedAt: DateTime
  vision: VisionCreateNestedManyWithoutPremiseInput
}

input PremiseCreateWithoutTagsOnPremisesInput {
  author: UserCreateNestedOneWithoutPremiseInput
  createdAt: DateTime
  id: String
  premisesOnTimelines: PremisesOnTimelinesCreateNestedManyWithoutPremiseInput
  status: PremiseStatus!
  thread: ThreadCreateNestedManyWithoutPremiseInput
  title: String!
  updatedAt: DateTime
  vision: VisionCreateNestedManyWithoutPremiseInput
}

input PremiseCreateWithoutThreadInput {
  author: UserCreateNestedOneWithoutPremiseInput
  createdAt: DateTime
  id: String
  premisesOnTimelines: PremisesOnTimelinesCreateNestedManyWithoutPremiseInput
  status: PremiseStatus!
  tagsOnPremises: TagsOnPremisesCreateNestedManyWithoutPremiseInput
  title: String!
  updatedAt: DateTime
  vision: VisionCreateNestedManyWithoutPremiseInput
}

input PremiseCreateWithoutVisionInput {
  author: UserCreateNestedOneWithoutPremiseInput
  createdAt: DateTime
  id: String
  premisesOnTimelines: PremisesOnTimelinesCreateNestedManyWithoutPremiseInput
  status: PremiseStatus!
  tagsOnPremises: TagsOnPremisesCreateNestedManyWithoutPremiseInput
  thread: ThreadCreateNestedManyWithoutPremiseInput
  title: String!
  updatedAt: DateTime
}

type PremiseGroupBy {
  _count: PremiseCountAggregate
  _max: PremiseMaxAggregate
  _min: PremiseMinAggregate
  authorId: String
  createdAt: DateTime!
  id: String!
  status: PremiseStatus!
  title: String!
  updatedAt: DateTime!
}

input PremiseListRelationFilter {
  every: PremiseWhereInput
  none: PremiseWhereInput
  some: PremiseWhereInput
}

type PremiseMaxAggregate {
  authorId: String
  createdAt: DateTime
  id: String
  status: PremiseStatus
  title: String
  updatedAt: DateTime
}

input PremiseMaxOrderByAggregateInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  status: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type PremiseMinAggregate {
  authorId: String
  createdAt: DateTime
  id: String
  status: PremiseStatus
  title: String
  updatedAt: DateTime
}

input PremiseMinOrderByAggregateInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  status: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input PremiseOrderByRelationAggregateInput {
  _count: SortOrder
}

input PremiseOrderByWithAggregationInput {
  _count: PremiseCountOrderByAggregateInput
  _max: PremiseMaxOrderByAggregateInput
  _min: PremiseMinOrderByAggregateInput
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  status: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input PremiseOrderByWithRelationInput {
  author: UserOrderByWithRelationInput
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  premisesOnTimelines: PremisesOnTimelinesOrderByRelationAggregateInput
  status: SortOrder
  tagsOnPremises: TagsOnPremisesOrderByRelationAggregateInput
  thread: ThreadOrderByRelationAggregateInput
  title: SortOrder
  updatedAt: SortOrder
  vision: VisionOrderByRelationAggregateInput
}

input PremiseRelationFilter {
  is: PremiseWhereInput
  isNot: PremiseWhereInput
}

enum PremiseScalarFieldEnum {
  authorId
  createdAt
  id
  status
  title
  updatedAt
}

input PremiseScalarWhereInput {
  AND: [PremiseScalarWhereInput!]
  NOT: [PremiseScalarWhereInput!]
  OR: [PremiseScalarWhereInput!]
  authorId: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  status: EnumPremiseStatusFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input PremiseScalarWhereWithAggregatesInput {
  AND: [PremiseScalarWhereWithAggregatesInput!]
  NOT: [PremiseScalarWhereWithAggregatesInput!]
  OR: [PremiseScalarWhereWithAggregatesInput!]
  authorId: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  status: EnumPremiseStatusWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

enum PremiseStatus {
  MISINFORMATION
  REFERENCE_PROVIDED
  RUMOUR
  UNVERIFIED
  VERIFIED
}

input PremiseUpdateInput {
  author: UserUpdateOneWithoutPremiseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premisesOnTimelines: PremisesOnTimelinesUpdateManyWithoutPremiseInput
  status: EnumPremiseStatusFieldUpdateOperationsInput
  tagsOnPremises: TagsOnPremisesUpdateManyWithoutPremiseInput
  thread: ThreadUpdateManyWithoutPremiseInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  vision: VisionUpdateManyWithoutPremiseInput
}

input PremiseUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: EnumPremiseStatusFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PremiseUpdateManyWithWhereWithoutAuthorInput {
  data: PremiseUpdateManyMutationInput!
  where: PremiseScalarWhereInput!
}

input PremiseUpdateManyWithoutAuthorInput {
  connect: [PremiseWhereUniqueInput!]
  connectOrCreate: [PremiseCreateOrConnectWithoutAuthorInput!]
  create: [PremiseCreateWithoutAuthorInput!]
  createMany: PremiseCreateManyAuthorInputEnvelope
  delete: [PremiseWhereUniqueInput!]
  deleteMany: [PremiseScalarWhereInput!]
  disconnect: [PremiseWhereUniqueInput!]
  set: [PremiseWhereUniqueInput!]
  update: [PremiseUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PremiseUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [PremiseUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PremiseUpdateOneRequiredWithoutPremisesOnTimelinesInput {
  connect: PremiseWhereUniqueInput
  connectOrCreate: PremiseCreateOrConnectWithoutPremisesOnTimelinesInput
  create: PremiseCreateWithoutPremisesOnTimelinesInput
  update: PremiseUpdateWithoutPremisesOnTimelinesInput
  upsert: PremiseUpsertWithoutPremisesOnTimelinesInput
}

input PremiseUpdateOneRequiredWithoutTagsOnPremisesInput {
  connect: PremiseWhereUniqueInput
  connectOrCreate: PremiseCreateOrConnectWithoutTagsOnPremisesInput
  create: PremiseCreateWithoutTagsOnPremisesInput
  update: PremiseUpdateWithoutTagsOnPremisesInput
  upsert: PremiseUpsertWithoutTagsOnPremisesInput
}

input PremiseUpdateOneRequiredWithoutThreadInput {
  connect: PremiseWhereUniqueInput
  connectOrCreate: PremiseCreateOrConnectWithoutThreadInput
  create: PremiseCreateWithoutThreadInput
  update: PremiseUpdateWithoutThreadInput
  upsert: PremiseUpsertWithoutThreadInput
}

input PremiseUpdateOneRequiredWithoutVisionInput {
  connect: PremiseWhereUniqueInput
  connectOrCreate: PremiseCreateOrConnectWithoutVisionInput
  create: PremiseCreateWithoutVisionInput
  update: PremiseUpdateWithoutVisionInput
  upsert: PremiseUpsertWithoutVisionInput
}

input PremiseUpdateWithWhereUniqueWithoutAuthorInput {
  data: PremiseUpdateWithoutAuthorInput!
  where: PremiseWhereUniqueInput!
}

input PremiseUpdateWithoutAuthorInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premisesOnTimelines: PremisesOnTimelinesUpdateManyWithoutPremiseInput
  status: EnumPremiseStatusFieldUpdateOperationsInput
  tagsOnPremises: TagsOnPremisesUpdateManyWithoutPremiseInput
  thread: ThreadUpdateManyWithoutPremiseInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  vision: VisionUpdateManyWithoutPremiseInput
}

input PremiseUpdateWithoutPremisesOnTimelinesInput {
  author: UserUpdateOneWithoutPremiseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: EnumPremiseStatusFieldUpdateOperationsInput
  tagsOnPremises: TagsOnPremisesUpdateManyWithoutPremiseInput
  thread: ThreadUpdateManyWithoutPremiseInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  vision: VisionUpdateManyWithoutPremiseInput
}

input PremiseUpdateWithoutTagsOnPremisesInput {
  author: UserUpdateOneWithoutPremiseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premisesOnTimelines: PremisesOnTimelinesUpdateManyWithoutPremiseInput
  status: EnumPremiseStatusFieldUpdateOperationsInput
  thread: ThreadUpdateManyWithoutPremiseInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  vision: VisionUpdateManyWithoutPremiseInput
}

input PremiseUpdateWithoutThreadInput {
  author: UserUpdateOneWithoutPremiseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premisesOnTimelines: PremisesOnTimelinesUpdateManyWithoutPremiseInput
  status: EnumPremiseStatusFieldUpdateOperationsInput
  tagsOnPremises: TagsOnPremisesUpdateManyWithoutPremiseInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  vision: VisionUpdateManyWithoutPremiseInput
}

input PremiseUpdateWithoutVisionInput {
  author: UserUpdateOneWithoutPremiseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premisesOnTimelines: PremisesOnTimelinesUpdateManyWithoutPremiseInput
  status: EnumPremiseStatusFieldUpdateOperationsInput
  tagsOnPremises: TagsOnPremisesUpdateManyWithoutPremiseInput
  thread: ThreadUpdateManyWithoutPremiseInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PremiseUpsertWithWhereUniqueWithoutAuthorInput {
  create: PremiseCreateWithoutAuthorInput!
  update: PremiseUpdateWithoutAuthorInput!
  where: PremiseWhereUniqueInput!
}

input PremiseUpsertWithoutPremisesOnTimelinesInput {
  create: PremiseCreateWithoutPremisesOnTimelinesInput!
  update: PremiseUpdateWithoutPremisesOnTimelinesInput!
}

input PremiseUpsertWithoutTagsOnPremisesInput {
  create: PremiseCreateWithoutTagsOnPremisesInput!
  update: PremiseUpdateWithoutTagsOnPremisesInput!
}

input PremiseUpsertWithoutThreadInput {
  create: PremiseCreateWithoutThreadInput!
  update: PremiseUpdateWithoutThreadInput!
}

input PremiseUpsertWithoutVisionInput {
  create: PremiseCreateWithoutVisionInput!
  update: PremiseUpdateWithoutVisionInput!
}

input PremiseWhereInput {
  AND: [PremiseWhereInput!]
  NOT: [PremiseWhereInput!]
  OR: [PremiseWhereInput!]
  author: UserRelationFilter
  authorId: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  premisesOnTimelines: PremisesOnTimelinesListRelationFilter
  status: EnumPremiseStatusFilter
  tagsOnPremises: TagsOnPremisesListRelationFilter
  thread: ThreadListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  vision: VisionListRelationFilter
}

input PremiseWhereUniqueInput {
  id: String
}

type PremisesOnTimelines {
  assignedAt: DateTime!
  premise: Premise!
  premiseId: String!
  timeline: Timeline!
  timelineId: String!
}

type PremisesOnTimelinesCountAggregate {
  _all: Int!
  assignedAt: Int!
  premiseId: Int!
  timelineId: Int!
}

input PremisesOnTimelinesCountOrderByAggregateInput {
  assignedAt: SortOrder
  premiseId: SortOrder
  timelineId: SortOrder
}

input PremisesOnTimelinesCreateInput {
  assignedAt: DateTime
  premise: PremiseCreateNestedOneWithoutPremisesOnTimelinesInput!
  timeline: TimelineCreateNestedOneWithoutPremisesOnTimelinesInput!
}

input PremisesOnTimelinesCreateManyInput {
  assignedAt: DateTime
  premiseId: String!
  timelineId: String!
}

input PremisesOnTimelinesCreateManyPremiseInput {
  assignedAt: DateTime
  timelineId: String!
}

input PremisesOnTimelinesCreateManyPremiseInputEnvelope {
  data: [PremisesOnTimelinesCreateManyPremiseInput!]!
  skipDuplicates: Boolean
}

input PremisesOnTimelinesCreateManyTimelineInput {
  assignedAt: DateTime
  premiseId: String!
}

input PremisesOnTimelinesCreateManyTimelineInputEnvelope {
  data: [PremisesOnTimelinesCreateManyTimelineInput!]!
  skipDuplicates: Boolean
}

input PremisesOnTimelinesCreateNestedManyWithoutPremiseInput {
  connect: [PremisesOnTimelinesWhereUniqueInput!]
  connectOrCreate: [PremisesOnTimelinesCreateOrConnectWithoutPremiseInput!]
  create: [PremisesOnTimelinesCreateWithoutPremiseInput!]
  createMany: PremisesOnTimelinesCreateManyPremiseInputEnvelope
}

input PremisesOnTimelinesCreateNestedManyWithoutTimelineInput {
  connect: [PremisesOnTimelinesWhereUniqueInput!]
  connectOrCreate: [PremisesOnTimelinesCreateOrConnectWithoutTimelineInput!]
  create: [PremisesOnTimelinesCreateWithoutTimelineInput!]
  createMany: PremisesOnTimelinesCreateManyTimelineInputEnvelope
}

input PremisesOnTimelinesCreateOrConnectWithoutPremiseInput {
  create: PremisesOnTimelinesCreateWithoutPremiseInput!
  where: PremisesOnTimelinesWhereUniqueInput!
}

input PremisesOnTimelinesCreateOrConnectWithoutTimelineInput {
  create: PremisesOnTimelinesCreateWithoutTimelineInput!
  where: PremisesOnTimelinesWhereUniqueInput!
}

input PremisesOnTimelinesCreateWithoutPremiseInput {
  assignedAt: DateTime
  timeline: TimelineCreateNestedOneWithoutPremisesOnTimelinesInput!
}

input PremisesOnTimelinesCreateWithoutTimelineInput {
  assignedAt: DateTime
  premise: PremiseCreateNestedOneWithoutPremisesOnTimelinesInput!
}

type PremisesOnTimelinesGroupBy {
  _count: PremisesOnTimelinesCountAggregate
  _max: PremisesOnTimelinesMaxAggregate
  _min: PremisesOnTimelinesMinAggregate
  assignedAt: DateTime!
  premiseId: String!
  timelineId: String!
}

input PremisesOnTimelinesListRelationFilter {
  every: PremisesOnTimelinesWhereInput
  none: PremisesOnTimelinesWhereInput
  some: PremisesOnTimelinesWhereInput
}

type PremisesOnTimelinesMaxAggregate {
  assignedAt: DateTime
  premiseId: String
  timelineId: String
}

input PremisesOnTimelinesMaxOrderByAggregateInput {
  assignedAt: SortOrder
  premiseId: SortOrder
  timelineId: SortOrder
}

type PremisesOnTimelinesMinAggregate {
  assignedAt: DateTime
  premiseId: String
  timelineId: String
}

input PremisesOnTimelinesMinOrderByAggregateInput {
  assignedAt: SortOrder
  premiseId: SortOrder
  timelineId: SortOrder
}

input PremisesOnTimelinesOrderByRelationAggregateInput {
  _count: SortOrder
}

input PremisesOnTimelinesOrderByWithAggregationInput {
  _count: PremisesOnTimelinesCountOrderByAggregateInput
  _max: PremisesOnTimelinesMaxOrderByAggregateInput
  _min: PremisesOnTimelinesMinOrderByAggregateInput
  assignedAt: SortOrder
  premiseId: SortOrder
  timelineId: SortOrder
}

input PremisesOnTimelinesOrderByWithRelationInput {
  assignedAt: SortOrder
  premise: PremiseOrderByWithRelationInput
  premiseId: SortOrder
  timeline: TimelineOrderByWithRelationInput
  timelineId: SortOrder
}

input PremisesOnTimelinesPremiseIdTimelineIdCompoundUniqueInput {
  premiseId: String!
  timelineId: String!
}

enum PremisesOnTimelinesScalarFieldEnum {
  assignedAt
  premiseId
  timelineId
}

input PremisesOnTimelinesScalarWhereInput {
  AND: [PremisesOnTimelinesScalarWhereInput!]
  NOT: [PremisesOnTimelinesScalarWhereInput!]
  OR: [PremisesOnTimelinesScalarWhereInput!]
  assignedAt: DateTimeFilter
  premiseId: StringFilter
  timelineId: StringFilter
}

input PremisesOnTimelinesScalarWhereWithAggregatesInput {
  AND: [PremisesOnTimelinesScalarWhereWithAggregatesInput!]
  NOT: [PremisesOnTimelinesScalarWhereWithAggregatesInput!]
  OR: [PremisesOnTimelinesScalarWhereWithAggregatesInput!]
  assignedAt: DateTimeWithAggregatesFilter
  premiseId: StringWithAggregatesFilter
  timelineId: StringWithAggregatesFilter
}

input PremisesOnTimelinesUpdateInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  premise: PremiseUpdateOneRequiredWithoutPremisesOnTimelinesInput
  timeline: TimelineUpdateOneRequiredWithoutPremisesOnTimelinesInput
}

input PremisesOnTimelinesUpdateManyMutationInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
}

input PremisesOnTimelinesUpdateManyWithWhereWithoutPremiseInput {
  data: PremisesOnTimelinesUpdateManyMutationInput!
  where: PremisesOnTimelinesScalarWhereInput!
}

input PremisesOnTimelinesUpdateManyWithWhereWithoutTimelineInput {
  data: PremisesOnTimelinesUpdateManyMutationInput!
  where: PremisesOnTimelinesScalarWhereInput!
}

input PremisesOnTimelinesUpdateManyWithoutPremiseInput {
  connect: [PremisesOnTimelinesWhereUniqueInput!]
  connectOrCreate: [PremisesOnTimelinesCreateOrConnectWithoutPremiseInput!]
  create: [PremisesOnTimelinesCreateWithoutPremiseInput!]
  createMany: PremisesOnTimelinesCreateManyPremiseInputEnvelope
  delete: [PremisesOnTimelinesWhereUniqueInput!]
  deleteMany: [PremisesOnTimelinesScalarWhereInput!]
  disconnect: [PremisesOnTimelinesWhereUniqueInput!]
  set: [PremisesOnTimelinesWhereUniqueInput!]
  update: [PremisesOnTimelinesUpdateWithWhereUniqueWithoutPremiseInput!]
  updateMany: [PremisesOnTimelinesUpdateManyWithWhereWithoutPremiseInput!]
  upsert: [PremisesOnTimelinesUpsertWithWhereUniqueWithoutPremiseInput!]
}

input PremisesOnTimelinesUpdateManyWithoutTimelineInput {
  connect: [PremisesOnTimelinesWhereUniqueInput!]
  connectOrCreate: [PremisesOnTimelinesCreateOrConnectWithoutTimelineInput!]
  create: [PremisesOnTimelinesCreateWithoutTimelineInput!]
  createMany: PremisesOnTimelinesCreateManyTimelineInputEnvelope
  delete: [PremisesOnTimelinesWhereUniqueInput!]
  deleteMany: [PremisesOnTimelinesScalarWhereInput!]
  disconnect: [PremisesOnTimelinesWhereUniqueInput!]
  set: [PremisesOnTimelinesWhereUniqueInput!]
  update: [PremisesOnTimelinesUpdateWithWhereUniqueWithoutTimelineInput!]
  updateMany: [PremisesOnTimelinesUpdateManyWithWhereWithoutTimelineInput!]
  upsert: [PremisesOnTimelinesUpsertWithWhereUniqueWithoutTimelineInput!]
}

input PremisesOnTimelinesUpdateWithWhereUniqueWithoutPremiseInput {
  data: PremisesOnTimelinesUpdateWithoutPremiseInput!
  where: PremisesOnTimelinesWhereUniqueInput!
}

input PremisesOnTimelinesUpdateWithWhereUniqueWithoutTimelineInput {
  data: PremisesOnTimelinesUpdateWithoutTimelineInput!
  where: PremisesOnTimelinesWhereUniqueInput!
}

input PremisesOnTimelinesUpdateWithoutPremiseInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  timeline: TimelineUpdateOneRequiredWithoutPremisesOnTimelinesInput
}

input PremisesOnTimelinesUpdateWithoutTimelineInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  premise: PremiseUpdateOneRequiredWithoutPremisesOnTimelinesInput
}

input PremisesOnTimelinesUpsertWithWhereUniqueWithoutPremiseInput {
  create: PremisesOnTimelinesCreateWithoutPremiseInput!
  update: PremisesOnTimelinesUpdateWithoutPremiseInput!
  where: PremisesOnTimelinesWhereUniqueInput!
}

input PremisesOnTimelinesUpsertWithWhereUniqueWithoutTimelineInput {
  create: PremisesOnTimelinesCreateWithoutTimelineInput!
  update: PremisesOnTimelinesUpdateWithoutTimelineInput!
  where: PremisesOnTimelinesWhereUniqueInput!
}

input PremisesOnTimelinesWhereInput {
  AND: [PremisesOnTimelinesWhereInput!]
  NOT: [PremisesOnTimelinesWhereInput!]
  OR: [PremisesOnTimelinesWhereInput!]
  assignedAt: DateTimeFilter
  premise: PremiseRelationFilter
  premiseId: StringFilter
  timeline: TimelineRelationFilter
  timelineId: StringFilter
}

input PremisesOnTimelinesWhereUniqueInput {
  premiseId_timelineId: PremisesOnTimelinesPremiseIdTimelineIdCompoundUniqueInput
}

type Query {
  aggregatePremise(cursor: PremiseWhereUniqueInput, orderBy: [PremiseOrderByWithRelationInput!], skip: Int, take: Int, where: PremiseWhereInput): AggregatePremise!
  aggregatePremisesOnTimelines(cursor: PremisesOnTimelinesWhereUniqueInput, orderBy: [PremisesOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: PremisesOnTimelinesWhereInput): AggregatePremisesOnTimelines!
  aggregateSnapshot(cursor: SnapshotWhereUniqueInput, orderBy: [SnapshotOrderByWithRelationInput!], skip: Int, take: Int, where: SnapshotWhereInput): AggregateSnapshot!
  aggregateTag(cursor: TagWhereUniqueInput, orderBy: [TagOrderByWithRelationInput!], skip: Int, take: Int, where: TagWhereInput): AggregateTag!
  aggregateTagsOnPremises(cursor: TagsOnPremisesWhereUniqueInput, orderBy: [TagsOnPremisesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnPremisesWhereInput): AggregateTagsOnPremises!
  aggregateTagsOnTimelines(cursor: TagsOnTimelinesWhereUniqueInput, orderBy: [TagsOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnTimelinesWhereInput): AggregateTagsOnTimelines!
  aggregateThread(cursor: ThreadWhereUniqueInput, orderBy: [ThreadOrderByWithRelationInput!], skip: Int, take: Int, where: ThreadWhereInput): AggregateThread!
  aggregateTimeline(cursor: TimelineWhereUniqueInput, orderBy: [TimelineOrderByWithRelationInput!], skip: Int, take: Int, where: TimelineWhereInput): AggregateTimeline!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  aggregateVision(cursor: VisionWhereUniqueInput, orderBy: [VisionOrderByWithRelationInput!], skip: Int, take: Int, where: VisionWhereInput): AggregateVision!
  findFirstPremise(cursor: PremiseWhereUniqueInput, distinct: [PremiseScalarFieldEnum!], orderBy: [PremiseOrderByWithRelationInput!], skip: Int, take: Int, where: PremiseWhereInput): Premise
  findFirstPremisesOnTimelines(cursor: PremisesOnTimelinesWhereUniqueInput, distinct: [PremisesOnTimelinesScalarFieldEnum!], orderBy: [PremisesOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: PremisesOnTimelinesWhereInput): PremisesOnTimelines
  findFirstSnapshot(cursor: SnapshotWhereUniqueInput, distinct: [SnapshotScalarFieldEnum!], orderBy: [SnapshotOrderByWithRelationInput!], skip: Int, take: Int, where: SnapshotWhereInput): Snapshot
  findFirstTag(cursor: TagWhereUniqueInput, distinct: [TagScalarFieldEnum!], orderBy: [TagOrderByWithRelationInput!], skip: Int, take: Int, where: TagWhereInput): Tag
  findFirstTagsOnPremises(cursor: TagsOnPremisesWhereUniqueInput, distinct: [TagsOnPremisesScalarFieldEnum!], orderBy: [TagsOnPremisesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnPremisesWhereInput): TagsOnPremises
  findFirstTagsOnTimelines(cursor: TagsOnTimelinesWhereUniqueInput, distinct: [TagsOnTimelinesScalarFieldEnum!], orderBy: [TagsOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnTimelinesWhereInput): TagsOnTimelines
  findFirstThread(cursor: ThreadWhereUniqueInput, distinct: [ThreadScalarFieldEnum!], orderBy: [ThreadOrderByWithRelationInput!], skip: Int, take: Int, where: ThreadWhereInput): Thread
  findFirstTimeline(cursor: TimelineWhereUniqueInput, distinct: [TimelineScalarFieldEnum!], orderBy: [TimelineOrderByWithRelationInput!], skip: Int, take: Int, where: TimelineWhereInput): Timeline
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstVision(cursor: VisionWhereUniqueInput, distinct: [VisionScalarFieldEnum!], orderBy: [VisionOrderByWithRelationInput!], skip: Int, take: Int, where: VisionWhereInput): Vision
  findManyPremisesOnTimelines(cursor: PremisesOnTimelinesWhereUniqueInput, distinct: [PremisesOnTimelinesScalarFieldEnum!], orderBy: [PremisesOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: PremisesOnTimelinesWhereInput): [PremisesOnTimelines!]!
  findManyTagsOnPremises(cursor: TagsOnPremisesWhereUniqueInput, distinct: [TagsOnPremisesScalarFieldEnum!], orderBy: [TagsOnPremisesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnPremisesWhereInput): [TagsOnPremises!]!
  findManyTagsOnTimelines(cursor: TagsOnTimelinesWhereUniqueInput, distinct: [TagsOnTimelinesScalarFieldEnum!], orderBy: [TagsOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnTimelinesWhereInput): [TagsOnTimelines!]!
  findUniquePremisesOnTimelines(where: PremisesOnTimelinesWhereUniqueInput!): PremisesOnTimelines
  findUniqueTagsOnPremises(where: TagsOnPremisesWhereUniqueInput!): TagsOnPremises
  findUniqueTagsOnTimelines(where: TagsOnTimelinesWhereUniqueInput!): TagsOnTimelines
  groupByPremise(by: [PremiseScalarFieldEnum!]!, having: PremiseScalarWhereWithAggregatesInput, orderBy: [PremiseOrderByWithAggregationInput!], skip: Int, take: Int, where: PremiseWhereInput): [PremiseGroupBy!]!
  groupByPremisesOnTimelines(by: [PremisesOnTimelinesScalarFieldEnum!]!, having: PremisesOnTimelinesScalarWhereWithAggregatesInput, orderBy: [PremisesOnTimelinesOrderByWithAggregationInput!], skip: Int, take: Int, where: PremisesOnTimelinesWhereInput): [PremisesOnTimelinesGroupBy!]!
  groupBySnapshot(by: [SnapshotScalarFieldEnum!]!, having: SnapshotScalarWhereWithAggregatesInput, orderBy: [SnapshotOrderByWithAggregationInput!], skip: Int, take: Int, where: SnapshotWhereInput): [SnapshotGroupBy!]!
  groupByTag(by: [TagScalarFieldEnum!]!, having: TagScalarWhereWithAggregatesInput, orderBy: [TagOrderByWithAggregationInput!], skip: Int, take: Int, where: TagWhereInput): [TagGroupBy!]!
  groupByTagsOnPremises(by: [TagsOnPremisesScalarFieldEnum!]!, having: TagsOnPremisesScalarWhereWithAggregatesInput, orderBy: [TagsOnPremisesOrderByWithAggregationInput!], skip: Int, take: Int, where: TagsOnPremisesWhereInput): [TagsOnPremisesGroupBy!]!
  groupByTagsOnTimelines(by: [TagsOnTimelinesScalarFieldEnum!]!, having: TagsOnTimelinesScalarWhereWithAggregatesInput, orderBy: [TagsOnTimelinesOrderByWithAggregationInput!], skip: Int, take: Int, where: TagsOnTimelinesWhereInput): [TagsOnTimelinesGroupBy!]!
  groupByThread(by: [ThreadScalarFieldEnum!]!, having: ThreadScalarWhereWithAggregatesInput, orderBy: [ThreadOrderByWithAggregationInput!], skip: Int, take: Int, where: ThreadWhereInput): [ThreadGroupBy!]!
  groupByTimeline(by: [TimelineScalarFieldEnum!]!, having: TimelineScalarWhereWithAggregatesInput, orderBy: [TimelineOrderByWithAggregationInput!], skip: Int, take: Int, where: TimelineWhereInput): [TimelineGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  groupByVision(by: [VisionScalarFieldEnum!]!, having: VisionScalarWhereWithAggregatesInput, orderBy: [VisionOrderByWithAggregationInput!], skip: Int, take: Int, where: VisionWhereInput): [VisionGroupBy!]!
  premise(where: PremiseWhereUniqueInput!): Premise
  premises(cursor: PremiseWhereUniqueInput, distinct: [PremiseScalarFieldEnum!], orderBy: [PremiseOrderByWithRelationInput!], skip: Int, take: Int, where: PremiseWhereInput): [Premise!]!
  snapshot(where: SnapshotWhereUniqueInput!): Snapshot
  snapshots(cursor: SnapshotWhereUniqueInput, distinct: [SnapshotScalarFieldEnum!], orderBy: [SnapshotOrderByWithRelationInput!], skip: Int, take: Int, where: SnapshotWhereInput): [Snapshot!]!
  tag(where: TagWhereUniqueInput!): Tag
  tags(cursor: TagWhereUniqueInput, distinct: [TagScalarFieldEnum!], orderBy: [TagOrderByWithRelationInput!], skip: Int, take: Int, where: TagWhereInput): [Tag!]!
  thread(where: ThreadWhereUniqueInput!): Thread
  threads(cursor: ThreadWhereUniqueInput, distinct: [ThreadScalarFieldEnum!], orderBy: [ThreadOrderByWithRelationInput!], skip: Int, take: Int, where: ThreadWhereInput): [Thread!]!
  timeline(where: TimelineWhereUniqueInput!): Timeline
  timelines(cursor: TimelineWhereUniqueInput, distinct: [TimelineScalarFieldEnum!], orderBy: [TimelineOrderByWithRelationInput!], skip: Int, take: Int, where: TimelineWhereInput): [Timeline!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  vision(where: VisionWhereUniqueInput!): Vision
  visions(cursor: VisionWhereUniqueInput, distinct: [VisionScalarFieldEnum!], orderBy: [VisionOrderByWithRelationInput!], skip: Int, take: Int, where: VisionWhereInput): [Vision!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  USER
}

type Snapshot {
  caption: String!
  createdAt: DateTime!
  id: String!
  sourceUrl: String!
  url: String!
  versionId: String!
}

type SnapshotCountAggregate {
  _all: Int!
  caption: Int!
  createdAt: Int!
  id: Int!
  sourceUrl: Int!
  url: Int!
  versionId: Int!
}

input SnapshotCountOrderByAggregateInput {
  caption: SortOrder
  createdAt: SortOrder
  id: SortOrder
  sourceUrl: SortOrder
  url: SortOrder
  versionId: SortOrder
}

input SnapshotCreateInput {
  caption: String!
  createdAt: DateTime
  id: String
  sourceUrl: String!
  url: String!
  versionId: String!
}

input SnapshotCreateManyInput {
  caption: String!
  createdAt: DateTime
  id: String
  sourceUrl: String!
  url: String!
  versionId: String!
}

type SnapshotGroupBy {
  _count: SnapshotCountAggregate
  _max: SnapshotMaxAggregate
  _min: SnapshotMinAggregate
  caption: String!
  createdAt: DateTime!
  id: String!
  sourceUrl: String!
  url: String!
  versionId: String!
}

type SnapshotMaxAggregate {
  caption: String
  createdAt: DateTime
  id: String
  sourceUrl: String
  url: String
  versionId: String
}

input SnapshotMaxOrderByAggregateInput {
  caption: SortOrder
  createdAt: SortOrder
  id: SortOrder
  sourceUrl: SortOrder
  url: SortOrder
  versionId: SortOrder
}

type SnapshotMinAggregate {
  caption: String
  createdAt: DateTime
  id: String
  sourceUrl: String
  url: String
  versionId: String
}

input SnapshotMinOrderByAggregateInput {
  caption: SortOrder
  createdAt: SortOrder
  id: SortOrder
  sourceUrl: SortOrder
  url: SortOrder
  versionId: SortOrder
}

input SnapshotOrderByWithAggregationInput {
  _count: SnapshotCountOrderByAggregateInput
  _max: SnapshotMaxOrderByAggregateInput
  _min: SnapshotMinOrderByAggregateInput
  caption: SortOrder
  createdAt: SortOrder
  id: SortOrder
  sourceUrl: SortOrder
  url: SortOrder
  versionId: SortOrder
}

input SnapshotOrderByWithRelationInput {
  caption: SortOrder
  createdAt: SortOrder
  id: SortOrder
  sourceUrl: SortOrder
  url: SortOrder
  versionId: SortOrder
}

enum SnapshotScalarFieldEnum {
  caption
  createdAt
  id
  sourceUrl
  url
  versionId
}

input SnapshotScalarWhereWithAggregatesInput {
  AND: [SnapshotScalarWhereWithAggregatesInput!]
  NOT: [SnapshotScalarWhereWithAggregatesInput!]
  OR: [SnapshotScalarWhereWithAggregatesInput!]
  caption: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  sourceUrl: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
  versionId: StringWithAggregatesFilter
}

input SnapshotUpdateInput {
  caption: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sourceUrl: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  versionId: StringFieldUpdateOperationsInput
}

input SnapshotUpdateManyMutationInput {
  caption: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sourceUrl: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  versionId: StringFieldUpdateOperationsInput
}

input SnapshotWhereInput {
  AND: [SnapshotWhereInput!]
  NOT: [SnapshotWhereInput!]
  OR: [SnapshotWhereInput!]
  caption: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  sourceUrl: StringFilter
  url: StringFilter
  versionId: StringFilter
}

input SnapshotWhereUniqueInput {
  id: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Tag {
  _count: TagCount
  id: Int!
  label: String!
  tagsOnPremises(cursor: TagsOnPremisesWhereUniqueInput, distinct: [TagsOnPremisesScalarFieldEnum!], orderBy: [TagsOnPremisesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnPremisesWhereInput): [TagsOnPremises!]!
  tagsOnTimelines(cursor: TagsOnTimelinesWhereUniqueInput, distinct: [TagsOnTimelinesScalarFieldEnum!], orderBy: [TagsOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnTimelinesWhereInput): [TagsOnTimelines!]!
}

type TagAvgAggregate {
  id: Float
}

input TagAvgOrderByAggregateInput {
  id: SortOrder
}

type TagCount {
  tagsOnPremises: Int!
  tagsOnTimelines: Int!
}

type TagCountAggregate {
  _all: Int!
  id: Int!
  label: Int!
}

input TagCountOrderByAggregateInput {
  id: SortOrder
  label: SortOrder
}

input TagCreateInput {
  label: String!
  tagsOnPremises: TagsOnPremisesCreateNestedManyWithoutTagInput
  tagsOnTimelines: TagsOnTimelinesCreateNestedManyWithoutTagInput
}

input TagCreateManyInput {
  id: Int
  label: String!
}

input TagCreateNestedOneWithoutTagsOnPremisesInput {
  connect: TagWhereUniqueInput
  connectOrCreate: TagCreateOrConnectWithoutTagsOnPremisesInput
  create: TagCreateWithoutTagsOnPremisesInput
}

input TagCreateNestedOneWithoutTagsOnTimelinesInput {
  connect: TagWhereUniqueInput
  connectOrCreate: TagCreateOrConnectWithoutTagsOnTimelinesInput
  create: TagCreateWithoutTagsOnTimelinesInput
}

input TagCreateOrConnectWithoutTagsOnPremisesInput {
  create: TagCreateWithoutTagsOnPremisesInput!
  where: TagWhereUniqueInput!
}

input TagCreateOrConnectWithoutTagsOnTimelinesInput {
  create: TagCreateWithoutTagsOnTimelinesInput!
  where: TagWhereUniqueInput!
}

input TagCreateWithoutTagsOnPremisesInput {
  label: String!
  tagsOnTimelines: TagsOnTimelinesCreateNestedManyWithoutTagInput
}

input TagCreateWithoutTagsOnTimelinesInput {
  label: String!
  tagsOnPremises: TagsOnPremisesCreateNestedManyWithoutTagInput
}

type TagGroupBy {
  _avg: TagAvgAggregate
  _count: TagCountAggregate
  _max: TagMaxAggregate
  _min: TagMinAggregate
  _sum: TagSumAggregate
  id: Int!
  label: String!
}

type TagMaxAggregate {
  id: Int
  label: String
}

input TagMaxOrderByAggregateInput {
  id: SortOrder
  label: SortOrder
}

type TagMinAggregate {
  id: Int
  label: String
}

input TagMinOrderByAggregateInput {
  id: SortOrder
  label: SortOrder
}

input TagOrderByWithAggregationInput {
  _avg: TagAvgOrderByAggregateInput
  _count: TagCountOrderByAggregateInput
  _max: TagMaxOrderByAggregateInput
  _min: TagMinOrderByAggregateInput
  _sum: TagSumOrderByAggregateInput
  id: SortOrder
  label: SortOrder
}

input TagOrderByWithRelationInput {
  id: SortOrder
  label: SortOrder
  tagsOnPremises: TagsOnPremisesOrderByRelationAggregateInput
  tagsOnTimelines: TagsOnTimelinesOrderByRelationAggregateInput
}

input TagRelationFilter {
  is: TagWhereInput
  isNot: TagWhereInput
}

enum TagScalarFieldEnum {
  id
  label
}

input TagScalarWhereWithAggregatesInput {
  AND: [TagScalarWhereWithAggregatesInput!]
  NOT: [TagScalarWhereWithAggregatesInput!]
  OR: [TagScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  label: StringWithAggregatesFilter
}

type TagSumAggregate {
  id: Int
}

input TagSumOrderByAggregateInput {
  id: SortOrder
}

input TagUpdateInput {
  label: StringFieldUpdateOperationsInput
  tagsOnPremises: TagsOnPremisesUpdateManyWithoutTagInput
  tagsOnTimelines: TagsOnTimelinesUpdateManyWithoutTagInput
}

input TagUpdateManyMutationInput {
  label: StringFieldUpdateOperationsInput
}

input TagUpdateOneRequiredWithoutTagsOnPremisesInput {
  connect: TagWhereUniqueInput
  connectOrCreate: TagCreateOrConnectWithoutTagsOnPremisesInput
  create: TagCreateWithoutTagsOnPremisesInput
  update: TagUpdateWithoutTagsOnPremisesInput
  upsert: TagUpsertWithoutTagsOnPremisesInput
}

input TagUpdateOneRequiredWithoutTagsOnTimelinesInput {
  connect: TagWhereUniqueInput
  connectOrCreate: TagCreateOrConnectWithoutTagsOnTimelinesInput
  create: TagCreateWithoutTagsOnTimelinesInput
  update: TagUpdateWithoutTagsOnTimelinesInput
  upsert: TagUpsertWithoutTagsOnTimelinesInput
}

input TagUpdateWithoutTagsOnPremisesInput {
  label: StringFieldUpdateOperationsInput
  tagsOnTimelines: TagsOnTimelinesUpdateManyWithoutTagInput
}

input TagUpdateWithoutTagsOnTimelinesInput {
  label: StringFieldUpdateOperationsInput
  tagsOnPremises: TagsOnPremisesUpdateManyWithoutTagInput
}

input TagUpsertWithoutTagsOnPremisesInput {
  create: TagCreateWithoutTagsOnPremisesInput!
  update: TagUpdateWithoutTagsOnPremisesInput!
}

input TagUpsertWithoutTagsOnTimelinesInput {
  create: TagCreateWithoutTagsOnTimelinesInput!
  update: TagUpdateWithoutTagsOnTimelinesInput!
}

input TagWhereInput {
  AND: [TagWhereInput!]
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  id: IntFilter
  label: StringFilter
  tagsOnPremises: TagsOnPremisesListRelationFilter
  tagsOnTimelines: TagsOnTimelinesListRelationFilter
}

input TagWhereUniqueInput {
  id: Int
  label: String
}

type TagsOnPremises {
  assignedAt: DateTime!
  premise: Premise!
  premiseId: String!
  tag: Tag!
  tagId: Int!
}

type TagsOnPremisesAvgAggregate {
  tagId: Float
}

input TagsOnPremisesAvgOrderByAggregateInput {
  tagId: SortOrder
}

type TagsOnPremisesCountAggregate {
  _all: Int!
  assignedAt: Int!
  premiseId: Int!
  tagId: Int!
}

input TagsOnPremisesCountOrderByAggregateInput {
  assignedAt: SortOrder
  premiseId: SortOrder
  tagId: SortOrder
}

input TagsOnPremisesCreateInput {
  assignedAt: DateTime
  premise: PremiseCreateNestedOneWithoutTagsOnPremisesInput!
  tag: TagCreateNestedOneWithoutTagsOnPremisesInput!
}

input TagsOnPremisesCreateManyInput {
  assignedAt: DateTime
  premiseId: String!
  tagId: Int!
}

input TagsOnPremisesCreateManyPremiseInput {
  assignedAt: DateTime
  tagId: Int!
}

input TagsOnPremisesCreateManyPremiseInputEnvelope {
  data: [TagsOnPremisesCreateManyPremiseInput!]!
  skipDuplicates: Boolean
}

input TagsOnPremisesCreateManyTagInput {
  assignedAt: DateTime
  premiseId: String!
}

input TagsOnPremisesCreateManyTagInputEnvelope {
  data: [TagsOnPremisesCreateManyTagInput!]!
  skipDuplicates: Boolean
}

input TagsOnPremisesCreateNestedManyWithoutPremiseInput {
  connect: [TagsOnPremisesWhereUniqueInput!]
  connectOrCreate: [TagsOnPremisesCreateOrConnectWithoutPremiseInput!]
  create: [TagsOnPremisesCreateWithoutPremiseInput!]
  createMany: TagsOnPremisesCreateManyPremiseInputEnvelope
}

input TagsOnPremisesCreateNestedManyWithoutTagInput {
  connect: [TagsOnPremisesWhereUniqueInput!]
  connectOrCreate: [TagsOnPremisesCreateOrConnectWithoutTagInput!]
  create: [TagsOnPremisesCreateWithoutTagInput!]
  createMany: TagsOnPremisesCreateManyTagInputEnvelope
}

input TagsOnPremisesCreateOrConnectWithoutPremiseInput {
  create: TagsOnPremisesCreateWithoutPremiseInput!
  where: TagsOnPremisesWhereUniqueInput!
}

input TagsOnPremisesCreateOrConnectWithoutTagInput {
  create: TagsOnPremisesCreateWithoutTagInput!
  where: TagsOnPremisesWhereUniqueInput!
}

input TagsOnPremisesCreateWithoutPremiseInput {
  assignedAt: DateTime
  tag: TagCreateNestedOneWithoutTagsOnPremisesInput!
}

input TagsOnPremisesCreateWithoutTagInput {
  assignedAt: DateTime
  premise: PremiseCreateNestedOneWithoutTagsOnPremisesInput!
}

type TagsOnPremisesGroupBy {
  _avg: TagsOnPremisesAvgAggregate
  _count: TagsOnPremisesCountAggregate
  _max: TagsOnPremisesMaxAggregate
  _min: TagsOnPremisesMinAggregate
  _sum: TagsOnPremisesSumAggregate
  assignedAt: DateTime!
  premiseId: String!
  tagId: Int!
}

input TagsOnPremisesListRelationFilter {
  every: TagsOnPremisesWhereInput
  none: TagsOnPremisesWhereInput
  some: TagsOnPremisesWhereInput
}

type TagsOnPremisesMaxAggregate {
  assignedAt: DateTime
  premiseId: String
  tagId: Int
}

input TagsOnPremisesMaxOrderByAggregateInput {
  assignedAt: SortOrder
  premiseId: SortOrder
  tagId: SortOrder
}

type TagsOnPremisesMinAggregate {
  assignedAt: DateTime
  premiseId: String
  tagId: Int
}

input TagsOnPremisesMinOrderByAggregateInput {
  assignedAt: SortOrder
  premiseId: SortOrder
  tagId: SortOrder
}

input TagsOnPremisesOrderByRelationAggregateInput {
  _count: SortOrder
}

input TagsOnPremisesOrderByWithAggregationInput {
  _avg: TagsOnPremisesAvgOrderByAggregateInput
  _count: TagsOnPremisesCountOrderByAggregateInput
  _max: TagsOnPremisesMaxOrderByAggregateInput
  _min: TagsOnPremisesMinOrderByAggregateInput
  _sum: TagsOnPremisesSumOrderByAggregateInput
  assignedAt: SortOrder
  premiseId: SortOrder
  tagId: SortOrder
}

input TagsOnPremisesOrderByWithRelationInput {
  assignedAt: SortOrder
  premise: PremiseOrderByWithRelationInput
  premiseId: SortOrder
  tag: TagOrderByWithRelationInput
  tagId: SortOrder
}

enum TagsOnPremisesScalarFieldEnum {
  assignedAt
  premiseId
  tagId
}

input TagsOnPremisesScalarWhereInput {
  AND: [TagsOnPremisesScalarWhereInput!]
  NOT: [TagsOnPremisesScalarWhereInput!]
  OR: [TagsOnPremisesScalarWhereInput!]
  assignedAt: DateTimeFilter
  premiseId: StringFilter
  tagId: IntFilter
}

input TagsOnPremisesScalarWhereWithAggregatesInput {
  AND: [TagsOnPremisesScalarWhereWithAggregatesInput!]
  NOT: [TagsOnPremisesScalarWhereWithAggregatesInput!]
  OR: [TagsOnPremisesScalarWhereWithAggregatesInput!]
  assignedAt: DateTimeWithAggregatesFilter
  premiseId: StringWithAggregatesFilter
  tagId: IntWithAggregatesFilter
}

type TagsOnPremisesSumAggregate {
  tagId: Int
}

input TagsOnPremisesSumOrderByAggregateInput {
  tagId: SortOrder
}

input TagsOnPremisesTagIdPremiseIdCompoundUniqueInput {
  premiseId: String!
  tagId: Int!
}

input TagsOnPremisesUpdateInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  premise: PremiseUpdateOneRequiredWithoutTagsOnPremisesInput
  tag: TagUpdateOneRequiredWithoutTagsOnPremisesInput
}

input TagsOnPremisesUpdateManyMutationInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
}

input TagsOnPremisesUpdateManyWithWhereWithoutPremiseInput {
  data: TagsOnPremisesUpdateManyMutationInput!
  where: TagsOnPremisesScalarWhereInput!
}

input TagsOnPremisesUpdateManyWithWhereWithoutTagInput {
  data: TagsOnPremisesUpdateManyMutationInput!
  where: TagsOnPremisesScalarWhereInput!
}

input TagsOnPremisesUpdateManyWithoutPremiseInput {
  connect: [TagsOnPremisesWhereUniqueInput!]
  connectOrCreate: [TagsOnPremisesCreateOrConnectWithoutPremiseInput!]
  create: [TagsOnPremisesCreateWithoutPremiseInput!]
  createMany: TagsOnPremisesCreateManyPremiseInputEnvelope
  delete: [TagsOnPremisesWhereUniqueInput!]
  deleteMany: [TagsOnPremisesScalarWhereInput!]
  disconnect: [TagsOnPremisesWhereUniqueInput!]
  set: [TagsOnPremisesWhereUniqueInput!]
  update: [TagsOnPremisesUpdateWithWhereUniqueWithoutPremiseInput!]
  updateMany: [TagsOnPremisesUpdateManyWithWhereWithoutPremiseInput!]
  upsert: [TagsOnPremisesUpsertWithWhereUniqueWithoutPremiseInput!]
}

input TagsOnPremisesUpdateManyWithoutTagInput {
  connect: [TagsOnPremisesWhereUniqueInput!]
  connectOrCreate: [TagsOnPremisesCreateOrConnectWithoutTagInput!]
  create: [TagsOnPremisesCreateWithoutTagInput!]
  createMany: TagsOnPremisesCreateManyTagInputEnvelope
  delete: [TagsOnPremisesWhereUniqueInput!]
  deleteMany: [TagsOnPremisesScalarWhereInput!]
  disconnect: [TagsOnPremisesWhereUniqueInput!]
  set: [TagsOnPremisesWhereUniqueInput!]
  update: [TagsOnPremisesUpdateWithWhereUniqueWithoutTagInput!]
  updateMany: [TagsOnPremisesUpdateManyWithWhereWithoutTagInput!]
  upsert: [TagsOnPremisesUpsertWithWhereUniqueWithoutTagInput!]
}

input TagsOnPremisesUpdateWithWhereUniqueWithoutPremiseInput {
  data: TagsOnPremisesUpdateWithoutPremiseInput!
  where: TagsOnPremisesWhereUniqueInput!
}

input TagsOnPremisesUpdateWithWhereUniqueWithoutTagInput {
  data: TagsOnPremisesUpdateWithoutTagInput!
  where: TagsOnPremisesWhereUniqueInput!
}

input TagsOnPremisesUpdateWithoutPremiseInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  tag: TagUpdateOneRequiredWithoutTagsOnPremisesInput
}

input TagsOnPremisesUpdateWithoutTagInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  premise: PremiseUpdateOneRequiredWithoutTagsOnPremisesInput
}

input TagsOnPremisesUpsertWithWhereUniqueWithoutPremiseInput {
  create: TagsOnPremisesCreateWithoutPremiseInput!
  update: TagsOnPremisesUpdateWithoutPremiseInput!
  where: TagsOnPremisesWhereUniqueInput!
}

input TagsOnPremisesUpsertWithWhereUniqueWithoutTagInput {
  create: TagsOnPremisesCreateWithoutTagInput!
  update: TagsOnPremisesUpdateWithoutTagInput!
  where: TagsOnPremisesWhereUniqueInput!
}

input TagsOnPremisesWhereInput {
  AND: [TagsOnPremisesWhereInput!]
  NOT: [TagsOnPremisesWhereInput!]
  OR: [TagsOnPremisesWhereInput!]
  assignedAt: DateTimeFilter
  premise: PremiseRelationFilter
  premiseId: StringFilter
  tag: TagRelationFilter
  tagId: IntFilter
}

input TagsOnPremisesWhereUniqueInput {
  tagId_premiseId: TagsOnPremisesTagIdPremiseIdCompoundUniqueInput
}

type TagsOnTimelines {
  assignedAt: DateTime!
  tag: Tag!
  tagId: Int!
  timeline: Timeline!
  timelineId: String!
}

type TagsOnTimelinesAvgAggregate {
  tagId: Float
}

input TagsOnTimelinesAvgOrderByAggregateInput {
  tagId: SortOrder
}

type TagsOnTimelinesCountAggregate {
  _all: Int!
  assignedAt: Int!
  tagId: Int!
  timelineId: Int!
}

input TagsOnTimelinesCountOrderByAggregateInput {
  assignedAt: SortOrder
  tagId: SortOrder
  timelineId: SortOrder
}

input TagsOnTimelinesCreateInput {
  assignedAt: DateTime
  tag: TagCreateNestedOneWithoutTagsOnTimelinesInput!
  timeline: TimelineCreateNestedOneWithoutTagsOnTimelinesInput!
}

input TagsOnTimelinesCreateManyInput {
  assignedAt: DateTime
  tagId: Int!
  timelineId: String!
}

input TagsOnTimelinesCreateManyTagInput {
  assignedAt: DateTime
  timelineId: String!
}

input TagsOnTimelinesCreateManyTagInputEnvelope {
  data: [TagsOnTimelinesCreateManyTagInput!]!
  skipDuplicates: Boolean
}

input TagsOnTimelinesCreateManyTimelineInput {
  assignedAt: DateTime
  tagId: Int!
}

input TagsOnTimelinesCreateManyTimelineInputEnvelope {
  data: [TagsOnTimelinesCreateManyTimelineInput!]!
  skipDuplicates: Boolean
}

input TagsOnTimelinesCreateNestedManyWithoutTagInput {
  connect: [TagsOnTimelinesWhereUniqueInput!]
  connectOrCreate: [TagsOnTimelinesCreateOrConnectWithoutTagInput!]
  create: [TagsOnTimelinesCreateWithoutTagInput!]
  createMany: TagsOnTimelinesCreateManyTagInputEnvelope
}

input TagsOnTimelinesCreateNestedManyWithoutTimelineInput {
  connect: [TagsOnTimelinesWhereUniqueInput!]
  connectOrCreate: [TagsOnTimelinesCreateOrConnectWithoutTimelineInput!]
  create: [TagsOnTimelinesCreateWithoutTimelineInput!]
  createMany: TagsOnTimelinesCreateManyTimelineInputEnvelope
}

input TagsOnTimelinesCreateOrConnectWithoutTagInput {
  create: TagsOnTimelinesCreateWithoutTagInput!
  where: TagsOnTimelinesWhereUniqueInput!
}

input TagsOnTimelinesCreateOrConnectWithoutTimelineInput {
  create: TagsOnTimelinesCreateWithoutTimelineInput!
  where: TagsOnTimelinesWhereUniqueInput!
}

input TagsOnTimelinesCreateWithoutTagInput {
  assignedAt: DateTime
  timeline: TimelineCreateNestedOneWithoutTagsOnTimelinesInput!
}

input TagsOnTimelinesCreateWithoutTimelineInput {
  assignedAt: DateTime
  tag: TagCreateNestedOneWithoutTagsOnTimelinesInput!
}

type TagsOnTimelinesGroupBy {
  _avg: TagsOnTimelinesAvgAggregate
  _count: TagsOnTimelinesCountAggregate
  _max: TagsOnTimelinesMaxAggregate
  _min: TagsOnTimelinesMinAggregate
  _sum: TagsOnTimelinesSumAggregate
  assignedAt: DateTime!
  tagId: Int!
  timelineId: String!
}

input TagsOnTimelinesListRelationFilter {
  every: TagsOnTimelinesWhereInput
  none: TagsOnTimelinesWhereInput
  some: TagsOnTimelinesWhereInput
}

type TagsOnTimelinesMaxAggregate {
  assignedAt: DateTime
  tagId: Int
  timelineId: String
}

input TagsOnTimelinesMaxOrderByAggregateInput {
  assignedAt: SortOrder
  tagId: SortOrder
  timelineId: SortOrder
}

type TagsOnTimelinesMinAggregate {
  assignedAt: DateTime
  tagId: Int
  timelineId: String
}

input TagsOnTimelinesMinOrderByAggregateInput {
  assignedAt: SortOrder
  tagId: SortOrder
  timelineId: SortOrder
}

input TagsOnTimelinesOrderByRelationAggregateInput {
  _count: SortOrder
}

input TagsOnTimelinesOrderByWithAggregationInput {
  _avg: TagsOnTimelinesAvgOrderByAggregateInput
  _count: TagsOnTimelinesCountOrderByAggregateInput
  _max: TagsOnTimelinesMaxOrderByAggregateInput
  _min: TagsOnTimelinesMinOrderByAggregateInput
  _sum: TagsOnTimelinesSumOrderByAggregateInput
  assignedAt: SortOrder
  tagId: SortOrder
  timelineId: SortOrder
}

input TagsOnTimelinesOrderByWithRelationInput {
  assignedAt: SortOrder
  tag: TagOrderByWithRelationInput
  tagId: SortOrder
  timeline: TimelineOrderByWithRelationInput
  timelineId: SortOrder
}

enum TagsOnTimelinesScalarFieldEnum {
  assignedAt
  tagId
  timelineId
}

input TagsOnTimelinesScalarWhereInput {
  AND: [TagsOnTimelinesScalarWhereInput!]
  NOT: [TagsOnTimelinesScalarWhereInput!]
  OR: [TagsOnTimelinesScalarWhereInput!]
  assignedAt: DateTimeFilter
  tagId: IntFilter
  timelineId: StringFilter
}

input TagsOnTimelinesScalarWhereWithAggregatesInput {
  AND: [TagsOnTimelinesScalarWhereWithAggregatesInput!]
  NOT: [TagsOnTimelinesScalarWhereWithAggregatesInput!]
  OR: [TagsOnTimelinesScalarWhereWithAggregatesInput!]
  assignedAt: DateTimeWithAggregatesFilter
  tagId: IntWithAggregatesFilter
  timelineId: StringWithAggregatesFilter
}

type TagsOnTimelinesSumAggregate {
  tagId: Int
}

input TagsOnTimelinesSumOrderByAggregateInput {
  tagId: SortOrder
}

input TagsOnTimelinesTagIdTimelineIdCompoundUniqueInput {
  tagId: Int!
  timelineId: String!
}

input TagsOnTimelinesUpdateInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  tag: TagUpdateOneRequiredWithoutTagsOnTimelinesInput
  timeline: TimelineUpdateOneRequiredWithoutTagsOnTimelinesInput
}

input TagsOnTimelinesUpdateManyMutationInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
}

input TagsOnTimelinesUpdateManyWithWhereWithoutTagInput {
  data: TagsOnTimelinesUpdateManyMutationInput!
  where: TagsOnTimelinesScalarWhereInput!
}

input TagsOnTimelinesUpdateManyWithWhereWithoutTimelineInput {
  data: TagsOnTimelinesUpdateManyMutationInput!
  where: TagsOnTimelinesScalarWhereInput!
}

input TagsOnTimelinesUpdateManyWithoutTagInput {
  connect: [TagsOnTimelinesWhereUniqueInput!]
  connectOrCreate: [TagsOnTimelinesCreateOrConnectWithoutTagInput!]
  create: [TagsOnTimelinesCreateWithoutTagInput!]
  createMany: TagsOnTimelinesCreateManyTagInputEnvelope
  delete: [TagsOnTimelinesWhereUniqueInput!]
  deleteMany: [TagsOnTimelinesScalarWhereInput!]
  disconnect: [TagsOnTimelinesWhereUniqueInput!]
  set: [TagsOnTimelinesWhereUniqueInput!]
  update: [TagsOnTimelinesUpdateWithWhereUniqueWithoutTagInput!]
  updateMany: [TagsOnTimelinesUpdateManyWithWhereWithoutTagInput!]
  upsert: [TagsOnTimelinesUpsertWithWhereUniqueWithoutTagInput!]
}

input TagsOnTimelinesUpdateManyWithoutTimelineInput {
  connect: [TagsOnTimelinesWhereUniqueInput!]
  connectOrCreate: [TagsOnTimelinesCreateOrConnectWithoutTimelineInput!]
  create: [TagsOnTimelinesCreateWithoutTimelineInput!]
  createMany: TagsOnTimelinesCreateManyTimelineInputEnvelope
  delete: [TagsOnTimelinesWhereUniqueInput!]
  deleteMany: [TagsOnTimelinesScalarWhereInput!]
  disconnect: [TagsOnTimelinesWhereUniqueInput!]
  set: [TagsOnTimelinesWhereUniqueInput!]
  update: [TagsOnTimelinesUpdateWithWhereUniqueWithoutTimelineInput!]
  updateMany: [TagsOnTimelinesUpdateManyWithWhereWithoutTimelineInput!]
  upsert: [TagsOnTimelinesUpsertWithWhereUniqueWithoutTimelineInput!]
}

input TagsOnTimelinesUpdateWithWhereUniqueWithoutTagInput {
  data: TagsOnTimelinesUpdateWithoutTagInput!
  where: TagsOnTimelinesWhereUniqueInput!
}

input TagsOnTimelinesUpdateWithWhereUniqueWithoutTimelineInput {
  data: TagsOnTimelinesUpdateWithoutTimelineInput!
  where: TagsOnTimelinesWhereUniqueInput!
}

input TagsOnTimelinesUpdateWithoutTagInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  timeline: TimelineUpdateOneRequiredWithoutTagsOnTimelinesInput
}

input TagsOnTimelinesUpdateWithoutTimelineInput {
  assignedAt: DateTimeFieldUpdateOperationsInput
  tag: TagUpdateOneRequiredWithoutTagsOnTimelinesInput
}

input TagsOnTimelinesUpsertWithWhereUniqueWithoutTagInput {
  create: TagsOnTimelinesCreateWithoutTagInput!
  update: TagsOnTimelinesUpdateWithoutTagInput!
  where: TagsOnTimelinesWhereUniqueInput!
}

input TagsOnTimelinesUpsertWithWhereUniqueWithoutTimelineInput {
  create: TagsOnTimelinesCreateWithoutTimelineInput!
  update: TagsOnTimelinesUpdateWithoutTimelineInput!
  where: TagsOnTimelinesWhereUniqueInput!
}

input TagsOnTimelinesWhereInput {
  AND: [TagsOnTimelinesWhereInput!]
  NOT: [TagsOnTimelinesWhereInput!]
  OR: [TagsOnTimelinesWhereInput!]
  assignedAt: DateTimeFilter
  tag: TagRelationFilter
  tagId: IntFilter
  timeline: TimelineRelationFilter
  timelineId: StringFilter
}

input TagsOnTimelinesWhereUniqueInput {
  tagId_timelineId: TagsOnTimelinesTagIdTimelineIdCompoundUniqueInput
}

type Thread {
  _count: ThreadCount
  activityDate: DateTime!
  childThreads(cursor: ThreadWhereUniqueInput, distinct: [ThreadScalarFieldEnum!], orderBy: [ThreadOrderByWithRelationInput!], skip: Int, take: Int, where: ThreadWhereInput): [Thread!]!
  createdAt: DateTime!
  description: String!
  id: String!
  parentThread: Thread
  parentThreadId: String
  premise: Premise!
  premiseId: String!
  reference: String!
  title: String!
}

type ThreadCount {
  childThreads: Int!
}

type ThreadCountAggregate {
  _all: Int!
  activityDate: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  parentThreadId: Int!
  premiseId: Int!
  reference: Int!
  title: Int!
}

input ThreadCountOrderByAggregateInput {
  activityDate: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  parentThreadId: SortOrder
  premiseId: SortOrder
  reference: SortOrder
  title: SortOrder
}

input ThreadCreateInput {
  activityDate: DateTime!
  childThreads: ThreadCreateNestedManyWithoutParentThreadInput
  createdAt: DateTime
  description: String!
  id: String
  parentThread: ThreadCreateNestedOneWithoutChildThreadsInput
  premise: PremiseCreateNestedOneWithoutThreadInput!
  reference: String!
  title: String!
}

input ThreadCreateManyInput {
  activityDate: DateTime!
  createdAt: DateTime
  description: String!
  id: String
  parentThreadId: String
  premiseId: String!
  reference: String!
  title: String!
}

input ThreadCreateManyParentThreadInput {
  activityDate: DateTime!
  createdAt: DateTime
  description: String!
  id: String
  premiseId: String!
  reference: String!
  title: String!
}

input ThreadCreateManyParentThreadInputEnvelope {
  data: [ThreadCreateManyParentThreadInput!]!
  skipDuplicates: Boolean
}

input ThreadCreateManyPremiseInput {
  activityDate: DateTime!
  createdAt: DateTime
  description: String!
  id: String
  parentThreadId: String
  reference: String!
  title: String!
}

input ThreadCreateManyPremiseInputEnvelope {
  data: [ThreadCreateManyPremiseInput!]!
  skipDuplicates: Boolean
}

input ThreadCreateNestedManyWithoutParentThreadInput {
  connect: [ThreadWhereUniqueInput!]
  connectOrCreate: [ThreadCreateOrConnectWithoutParentThreadInput!]
  create: [ThreadCreateWithoutParentThreadInput!]
  createMany: ThreadCreateManyParentThreadInputEnvelope
}

input ThreadCreateNestedManyWithoutPremiseInput {
  connect: [ThreadWhereUniqueInput!]
  connectOrCreate: [ThreadCreateOrConnectWithoutPremiseInput!]
  create: [ThreadCreateWithoutPremiseInput!]
  createMany: ThreadCreateManyPremiseInputEnvelope
}

input ThreadCreateNestedOneWithoutChildThreadsInput {
  connect: ThreadWhereUniqueInput
  connectOrCreate: ThreadCreateOrConnectWithoutChildThreadsInput
  create: ThreadCreateWithoutChildThreadsInput
}

input ThreadCreateOrConnectWithoutChildThreadsInput {
  create: ThreadCreateWithoutChildThreadsInput!
  where: ThreadWhereUniqueInput!
}

input ThreadCreateOrConnectWithoutParentThreadInput {
  create: ThreadCreateWithoutParentThreadInput!
  where: ThreadWhereUniqueInput!
}

input ThreadCreateOrConnectWithoutPremiseInput {
  create: ThreadCreateWithoutPremiseInput!
  where: ThreadWhereUniqueInput!
}

input ThreadCreateWithoutChildThreadsInput {
  activityDate: DateTime!
  createdAt: DateTime
  description: String!
  id: String
  parentThread: ThreadCreateNestedOneWithoutChildThreadsInput
  premise: PremiseCreateNestedOneWithoutThreadInput!
  reference: String!
  title: String!
}

input ThreadCreateWithoutParentThreadInput {
  activityDate: DateTime!
  childThreads: ThreadCreateNestedManyWithoutParentThreadInput
  createdAt: DateTime
  description: String!
  id: String
  premise: PremiseCreateNestedOneWithoutThreadInput!
  reference: String!
  title: String!
}

input ThreadCreateWithoutPremiseInput {
  activityDate: DateTime!
  childThreads: ThreadCreateNestedManyWithoutParentThreadInput
  createdAt: DateTime
  description: String!
  id: String
  parentThread: ThreadCreateNestedOneWithoutChildThreadsInput
  reference: String!
  title: String!
}

type ThreadGroupBy {
  _count: ThreadCountAggregate
  _max: ThreadMaxAggregate
  _min: ThreadMinAggregate
  activityDate: DateTime!
  createdAt: DateTime!
  description: String!
  id: String!
  parentThreadId: String
  premiseId: String!
  reference: String!
  title: String!
}

input ThreadListRelationFilter {
  every: ThreadWhereInput
  none: ThreadWhereInput
  some: ThreadWhereInput
}

type ThreadMaxAggregate {
  activityDate: DateTime
  createdAt: DateTime
  description: String
  id: String
  parentThreadId: String
  premiseId: String
  reference: String
  title: String
}

input ThreadMaxOrderByAggregateInput {
  activityDate: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  parentThreadId: SortOrder
  premiseId: SortOrder
  reference: SortOrder
  title: SortOrder
}

type ThreadMinAggregate {
  activityDate: DateTime
  createdAt: DateTime
  description: String
  id: String
  parentThreadId: String
  premiseId: String
  reference: String
  title: String
}

input ThreadMinOrderByAggregateInput {
  activityDate: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  parentThreadId: SortOrder
  premiseId: SortOrder
  reference: SortOrder
  title: SortOrder
}

input ThreadOrderByRelationAggregateInput {
  _count: SortOrder
}

input ThreadOrderByWithAggregationInput {
  _count: ThreadCountOrderByAggregateInput
  _max: ThreadMaxOrderByAggregateInput
  _min: ThreadMinOrderByAggregateInput
  activityDate: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  parentThreadId: SortOrder
  premiseId: SortOrder
  reference: SortOrder
  title: SortOrder
}

input ThreadOrderByWithRelationInput {
  activityDate: SortOrder
  childThreads: ThreadOrderByRelationAggregateInput
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  parentThread: ThreadOrderByWithRelationInput
  parentThreadId: SortOrder
  premise: PremiseOrderByWithRelationInput
  premiseId: SortOrder
  reference: SortOrder
  title: SortOrder
}

input ThreadRelationFilter {
  is: ThreadWhereInput
  isNot: ThreadWhereInput
}

enum ThreadScalarFieldEnum {
  activityDate
  createdAt
  description
  id
  parentThreadId
  premiseId
  reference
  title
}

input ThreadScalarWhereInput {
  AND: [ThreadScalarWhereInput!]
  NOT: [ThreadScalarWhereInput!]
  OR: [ThreadScalarWhereInput!]
  activityDate: DateTimeFilter
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  parentThreadId: StringNullableFilter
  premiseId: StringFilter
  reference: StringFilter
  title: StringFilter
}

input ThreadScalarWhereWithAggregatesInput {
  AND: [ThreadScalarWhereWithAggregatesInput!]
  NOT: [ThreadScalarWhereWithAggregatesInput!]
  OR: [ThreadScalarWhereWithAggregatesInput!]
  activityDate: DateTimeWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  parentThreadId: StringNullableWithAggregatesFilter
  premiseId: StringWithAggregatesFilter
  reference: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
}

input ThreadUpdateInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  childThreads: ThreadUpdateManyWithoutParentThreadInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parentThread: ThreadUpdateOneWithoutChildThreadsInput
  premise: PremiseUpdateOneRequiredWithoutThreadInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input ThreadUpdateManyMutationInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input ThreadUpdateManyWithWhereWithoutParentThreadInput {
  data: ThreadUpdateManyMutationInput!
  where: ThreadScalarWhereInput!
}

input ThreadUpdateManyWithWhereWithoutPremiseInput {
  data: ThreadUpdateManyMutationInput!
  where: ThreadScalarWhereInput!
}

input ThreadUpdateManyWithoutParentThreadInput {
  connect: [ThreadWhereUniqueInput!]
  connectOrCreate: [ThreadCreateOrConnectWithoutParentThreadInput!]
  create: [ThreadCreateWithoutParentThreadInput!]
  createMany: ThreadCreateManyParentThreadInputEnvelope
  delete: [ThreadWhereUniqueInput!]
  deleteMany: [ThreadScalarWhereInput!]
  disconnect: [ThreadWhereUniqueInput!]
  set: [ThreadWhereUniqueInput!]
  update: [ThreadUpdateWithWhereUniqueWithoutParentThreadInput!]
  updateMany: [ThreadUpdateManyWithWhereWithoutParentThreadInput!]
  upsert: [ThreadUpsertWithWhereUniqueWithoutParentThreadInput!]
}

input ThreadUpdateManyWithoutPremiseInput {
  connect: [ThreadWhereUniqueInput!]
  connectOrCreate: [ThreadCreateOrConnectWithoutPremiseInput!]
  create: [ThreadCreateWithoutPremiseInput!]
  createMany: ThreadCreateManyPremiseInputEnvelope
  delete: [ThreadWhereUniqueInput!]
  deleteMany: [ThreadScalarWhereInput!]
  disconnect: [ThreadWhereUniqueInput!]
  set: [ThreadWhereUniqueInput!]
  update: [ThreadUpdateWithWhereUniqueWithoutPremiseInput!]
  updateMany: [ThreadUpdateManyWithWhereWithoutPremiseInput!]
  upsert: [ThreadUpsertWithWhereUniqueWithoutPremiseInput!]
}

input ThreadUpdateOneWithoutChildThreadsInput {
  connect: ThreadWhereUniqueInput
  connectOrCreate: ThreadCreateOrConnectWithoutChildThreadsInput
  create: ThreadCreateWithoutChildThreadsInput
  delete: Boolean
  disconnect: Boolean
  update: ThreadUpdateWithoutChildThreadsInput
  upsert: ThreadUpsertWithoutChildThreadsInput
}

input ThreadUpdateWithWhereUniqueWithoutParentThreadInput {
  data: ThreadUpdateWithoutParentThreadInput!
  where: ThreadWhereUniqueInput!
}

input ThreadUpdateWithWhereUniqueWithoutPremiseInput {
  data: ThreadUpdateWithoutPremiseInput!
  where: ThreadWhereUniqueInput!
}

input ThreadUpdateWithoutChildThreadsInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parentThread: ThreadUpdateOneWithoutChildThreadsInput
  premise: PremiseUpdateOneRequiredWithoutThreadInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input ThreadUpdateWithoutParentThreadInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  childThreads: ThreadUpdateManyWithoutParentThreadInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premise: PremiseUpdateOneRequiredWithoutThreadInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input ThreadUpdateWithoutPremiseInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  childThreads: ThreadUpdateManyWithoutParentThreadInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parentThread: ThreadUpdateOneWithoutChildThreadsInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input ThreadUpsertWithWhereUniqueWithoutParentThreadInput {
  create: ThreadCreateWithoutParentThreadInput!
  update: ThreadUpdateWithoutParentThreadInput!
  where: ThreadWhereUniqueInput!
}

input ThreadUpsertWithWhereUniqueWithoutPremiseInput {
  create: ThreadCreateWithoutPremiseInput!
  update: ThreadUpdateWithoutPremiseInput!
  where: ThreadWhereUniqueInput!
}

input ThreadUpsertWithoutChildThreadsInput {
  create: ThreadCreateWithoutChildThreadsInput!
  update: ThreadUpdateWithoutChildThreadsInput!
}

input ThreadWhereInput {
  AND: [ThreadWhereInput!]
  NOT: [ThreadWhereInput!]
  OR: [ThreadWhereInput!]
  activityDate: DateTimeFilter
  childThreads: ThreadListRelationFilter
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  parentThread: ThreadRelationFilter
  parentThreadId: StringNullableFilter
  premise: PremiseRelationFilter
  premiseId: StringFilter
  reference: StringFilter
  title: StringFilter
}

input ThreadWhereUniqueInput {
  id: String
}

type Timeline {
  _count: TimelineCount
  author: User!
  authorId: String!
  description: String!
  id: String!
  premisesOnTimelines(cursor: PremisesOnTimelinesWhereUniqueInput, distinct: [PremisesOnTimelinesScalarFieldEnum!], orderBy: [PremisesOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: PremisesOnTimelinesWhereInput): [PremisesOnTimelines!]!
  status: String!
  tagsOnTimelines(cursor: TagsOnTimelinesWhereUniqueInput, distinct: [TagsOnTimelinesScalarFieldEnum!], orderBy: [TagsOnTimelinesOrderByWithRelationInput!], skip: Int, take: Int, where: TagsOnTimelinesWhereInput): [TagsOnTimelines!]!
  title: String!
}

type TimelineCount {
  premisesOnTimelines: Int!
  tagsOnTimelines: Int!
}

type TimelineCountAggregate {
  _all: Int!
  authorId: Int!
  description: Int!
  id: Int!
  status: Int!
  title: Int!
}

input TimelineCountOrderByAggregateInput {
  authorId: SortOrder
  description: SortOrder
  id: SortOrder
  status: SortOrder
  title: SortOrder
}

input TimelineCreateInput {
  author: UserCreateNestedOneWithoutTimelineInput!
  description: String!
  id: String
  premisesOnTimelines: PremisesOnTimelinesCreateNestedManyWithoutTimelineInput
  status: String!
  tagsOnTimelines: TagsOnTimelinesCreateNestedManyWithoutTimelineInput
  title: String!
}

input TimelineCreateManyAuthorInput {
  description: String!
  id: String
  status: String!
  title: String!
}

input TimelineCreateManyAuthorInputEnvelope {
  data: [TimelineCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input TimelineCreateManyInput {
  authorId: String!
  description: String!
  id: String
  status: String!
  title: String!
}

input TimelineCreateNestedManyWithoutAuthorInput {
  connect: [TimelineWhereUniqueInput!]
  connectOrCreate: [TimelineCreateOrConnectWithoutAuthorInput!]
  create: [TimelineCreateWithoutAuthorInput!]
  createMany: TimelineCreateManyAuthorInputEnvelope
}

input TimelineCreateNestedOneWithoutPremisesOnTimelinesInput {
  connect: TimelineWhereUniqueInput
  connectOrCreate: TimelineCreateOrConnectWithoutPremisesOnTimelinesInput
  create: TimelineCreateWithoutPremisesOnTimelinesInput
}

input TimelineCreateNestedOneWithoutTagsOnTimelinesInput {
  connect: TimelineWhereUniqueInput
  connectOrCreate: TimelineCreateOrConnectWithoutTagsOnTimelinesInput
  create: TimelineCreateWithoutTagsOnTimelinesInput
}

input TimelineCreateOrConnectWithoutAuthorInput {
  create: TimelineCreateWithoutAuthorInput!
  where: TimelineWhereUniqueInput!
}

input TimelineCreateOrConnectWithoutPremisesOnTimelinesInput {
  create: TimelineCreateWithoutPremisesOnTimelinesInput!
  where: TimelineWhereUniqueInput!
}

input TimelineCreateOrConnectWithoutTagsOnTimelinesInput {
  create: TimelineCreateWithoutTagsOnTimelinesInput!
  where: TimelineWhereUniqueInput!
}

input TimelineCreateWithoutAuthorInput {
  description: String!
  id: String
  premisesOnTimelines: PremisesOnTimelinesCreateNestedManyWithoutTimelineInput
  status: String!
  tagsOnTimelines: TagsOnTimelinesCreateNestedManyWithoutTimelineInput
  title: String!
}

input TimelineCreateWithoutPremisesOnTimelinesInput {
  author: UserCreateNestedOneWithoutTimelineInput!
  description: String!
  id: String
  status: String!
  tagsOnTimelines: TagsOnTimelinesCreateNestedManyWithoutTimelineInput
  title: String!
}

input TimelineCreateWithoutTagsOnTimelinesInput {
  author: UserCreateNestedOneWithoutTimelineInput!
  description: String!
  id: String
  premisesOnTimelines: PremisesOnTimelinesCreateNestedManyWithoutTimelineInput
  status: String!
  title: String!
}

type TimelineGroupBy {
  _count: TimelineCountAggregate
  _max: TimelineMaxAggregate
  _min: TimelineMinAggregate
  authorId: String!
  description: String!
  id: String!
  status: String!
  title: String!
}

input TimelineListRelationFilter {
  every: TimelineWhereInput
  none: TimelineWhereInput
  some: TimelineWhereInput
}

type TimelineMaxAggregate {
  authorId: String
  description: String
  id: String
  status: String
  title: String
}

input TimelineMaxOrderByAggregateInput {
  authorId: SortOrder
  description: SortOrder
  id: SortOrder
  status: SortOrder
  title: SortOrder
}

type TimelineMinAggregate {
  authorId: String
  description: String
  id: String
  status: String
  title: String
}

input TimelineMinOrderByAggregateInput {
  authorId: SortOrder
  description: SortOrder
  id: SortOrder
  status: SortOrder
  title: SortOrder
}

input TimelineOrderByRelationAggregateInput {
  _count: SortOrder
}

input TimelineOrderByWithAggregationInput {
  _count: TimelineCountOrderByAggregateInput
  _max: TimelineMaxOrderByAggregateInput
  _min: TimelineMinOrderByAggregateInput
  authorId: SortOrder
  description: SortOrder
  id: SortOrder
  status: SortOrder
  title: SortOrder
}

input TimelineOrderByWithRelationInput {
  author: UserOrderByWithRelationInput
  authorId: SortOrder
  description: SortOrder
  id: SortOrder
  premisesOnTimelines: PremisesOnTimelinesOrderByRelationAggregateInput
  status: SortOrder
  tagsOnTimelines: TagsOnTimelinesOrderByRelationAggregateInput
  title: SortOrder
}

input TimelineRelationFilter {
  is: TimelineWhereInput
  isNot: TimelineWhereInput
}

enum TimelineScalarFieldEnum {
  authorId
  description
  id
  status
  title
}

input TimelineScalarWhereInput {
  AND: [TimelineScalarWhereInput!]
  NOT: [TimelineScalarWhereInput!]
  OR: [TimelineScalarWhereInput!]
  authorId: StringFilter
  description: StringFilter
  id: StringFilter
  status: StringFilter
  title: StringFilter
}

input TimelineScalarWhereWithAggregatesInput {
  AND: [TimelineScalarWhereWithAggregatesInput!]
  NOT: [TimelineScalarWhereWithAggregatesInput!]
  OR: [TimelineScalarWhereWithAggregatesInput!]
  authorId: StringWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  status: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
}

input TimelineUpdateInput {
  author: UserUpdateOneRequiredWithoutTimelineInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premisesOnTimelines: PremisesOnTimelinesUpdateManyWithoutTimelineInput
  status: StringFieldUpdateOperationsInput
  tagsOnTimelines: TagsOnTimelinesUpdateManyWithoutTimelineInput
  title: StringFieldUpdateOperationsInput
}

input TimelineUpdateManyMutationInput {
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input TimelineUpdateManyWithWhereWithoutAuthorInput {
  data: TimelineUpdateManyMutationInput!
  where: TimelineScalarWhereInput!
}

input TimelineUpdateManyWithoutAuthorInput {
  connect: [TimelineWhereUniqueInput!]
  connectOrCreate: [TimelineCreateOrConnectWithoutAuthorInput!]
  create: [TimelineCreateWithoutAuthorInput!]
  createMany: TimelineCreateManyAuthorInputEnvelope
  delete: [TimelineWhereUniqueInput!]
  deleteMany: [TimelineScalarWhereInput!]
  disconnect: [TimelineWhereUniqueInput!]
  set: [TimelineWhereUniqueInput!]
  update: [TimelineUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [TimelineUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [TimelineUpsertWithWhereUniqueWithoutAuthorInput!]
}

input TimelineUpdateOneRequiredWithoutPremisesOnTimelinesInput {
  connect: TimelineWhereUniqueInput
  connectOrCreate: TimelineCreateOrConnectWithoutPremisesOnTimelinesInput
  create: TimelineCreateWithoutPremisesOnTimelinesInput
  update: TimelineUpdateWithoutPremisesOnTimelinesInput
  upsert: TimelineUpsertWithoutPremisesOnTimelinesInput
}

input TimelineUpdateOneRequiredWithoutTagsOnTimelinesInput {
  connect: TimelineWhereUniqueInput
  connectOrCreate: TimelineCreateOrConnectWithoutTagsOnTimelinesInput
  create: TimelineCreateWithoutTagsOnTimelinesInput
  update: TimelineUpdateWithoutTagsOnTimelinesInput
  upsert: TimelineUpsertWithoutTagsOnTimelinesInput
}

input TimelineUpdateWithWhereUniqueWithoutAuthorInput {
  data: TimelineUpdateWithoutAuthorInput!
  where: TimelineWhereUniqueInput!
}

input TimelineUpdateWithoutAuthorInput {
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premisesOnTimelines: PremisesOnTimelinesUpdateManyWithoutTimelineInput
  status: StringFieldUpdateOperationsInput
  tagsOnTimelines: TagsOnTimelinesUpdateManyWithoutTimelineInput
  title: StringFieldUpdateOperationsInput
}

input TimelineUpdateWithoutPremisesOnTimelinesInput {
  author: UserUpdateOneRequiredWithoutTimelineInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  tagsOnTimelines: TagsOnTimelinesUpdateManyWithoutTimelineInput
  title: StringFieldUpdateOperationsInput
}

input TimelineUpdateWithoutTagsOnTimelinesInput {
  author: UserUpdateOneRequiredWithoutTimelineInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premisesOnTimelines: PremisesOnTimelinesUpdateManyWithoutTimelineInput
  status: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input TimelineUpsertWithWhereUniqueWithoutAuthorInput {
  create: TimelineCreateWithoutAuthorInput!
  update: TimelineUpdateWithoutAuthorInput!
  where: TimelineWhereUniqueInput!
}

input TimelineUpsertWithoutPremisesOnTimelinesInput {
  create: TimelineCreateWithoutPremisesOnTimelinesInput!
  update: TimelineUpdateWithoutPremisesOnTimelinesInput!
}

input TimelineUpsertWithoutTagsOnTimelinesInput {
  create: TimelineCreateWithoutTagsOnTimelinesInput!
  update: TimelineUpdateWithoutTagsOnTimelinesInput!
}

input TimelineWhereInput {
  AND: [TimelineWhereInput!]
  NOT: [TimelineWhereInput!]
  OR: [TimelineWhereInput!]
  author: UserRelationFilter
  authorId: StringFilter
  description: StringFilter
  id: StringFilter
  premisesOnTimelines: PremisesOnTimelinesListRelationFilter
  status: StringFilter
  tagsOnTimelines: TagsOnTimelinesListRelationFilter
  title: StringFilter
}

input TimelineWhereUniqueInput {
  id: String
}

type User {
  _count: UserCount
  createdAt: DateTime!
  email: String!
  id: String!
  name: String
  premise(cursor: PremiseWhereUniqueInput, distinct: [PremiseScalarFieldEnum!], orderBy: [PremiseOrderByWithRelationInput!], skip: Int, take: Int, where: PremiseWhereInput): [Premise!]!
  role: Role!
  timeline(cursor: TimelineWhereUniqueInput, distinct: [TimelineScalarFieldEnum!], orderBy: [TimelineOrderByWithRelationInput!], skip: Int, take: Int, where: TimelineWhereInput): [Timeline!]!
  vision(cursor: VisionWhereUniqueInput, distinct: [VisionScalarFieldEnum!], orderBy: [VisionOrderByWithRelationInput!], skip: Int, take: Int, where: VisionWhereInput): [Vision!]!
}

type UserCount {
  premise: Int!
  timeline: Int!
  vision: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  name: Int!
  role: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  role: SortOrder
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  id: String
  name: String
  premise: PremiseCreateNestedManyWithoutAuthorInput
  role: Role
  timeline: TimelineCreateNestedManyWithoutAuthorInput
  vision: VisionCreateNestedManyWithoutAuthorInput
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  id: String
  name: String
  role: Role
}

input UserCreateNestedOneWithoutPremiseInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPremiseInput
  create: UserCreateWithoutPremiseInput
}

input UserCreateNestedOneWithoutTimelineInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTimelineInput
  create: UserCreateWithoutTimelineInput
}

input UserCreateNestedOneWithoutVisionInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutVisionInput
  create: UserCreateWithoutVisionInput
}

input UserCreateOrConnectWithoutPremiseInput {
  create: UserCreateWithoutPremiseInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutTimelineInput {
  create: UserCreateWithoutTimelineInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutVisionInput {
  create: UserCreateWithoutVisionInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutPremiseInput {
  createdAt: DateTime
  email: String!
  id: String
  name: String
  role: Role
  timeline: TimelineCreateNestedManyWithoutAuthorInput
  vision: VisionCreateNestedManyWithoutAuthorInput
}

input UserCreateWithoutTimelineInput {
  createdAt: DateTime
  email: String!
  id: String
  name: String
  premise: PremiseCreateNestedManyWithoutAuthorInput
  role: Role
  vision: VisionCreateNestedManyWithoutAuthorInput
}

input UserCreateWithoutVisionInput {
  createdAt: DateTime
  email: String!
  id: String
  name: String
  premise: PremiseCreateNestedManyWithoutAuthorInput
  role: Role
  timeline: TimelineCreateNestedManyWithoutAuthorInput
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  createdAt: DateTime!
  email: String!
  id: String!
  name: String
  role: Role!
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  id: String
  name: String
  role: Role
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  role: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  id: String
  name: String
  role: Role
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  role: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  role: SortOrder
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  premise: PremiseOrderByRelationAggregateInput
  role: SortOrder
  timeline: TimelineOrderByRelationAggregateInput
  vision: VisionOrderByRelationAggregateInput
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  id
  name
  role
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  premise: PremiseUpdateManyWithoutAuthorInput
  role: EnumRoleFieldUpdateOperationsInput
  timeline: TimelineUpdateManyWithoutAuthorInput
  vision: VisionUpdateManyWithoutAuthorInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutTimelineInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTimelineInput
  create: UserCreateWithoutTimelineInput
  update: UserUpdateWithoutTimelineInput
  upsert: UserUpsertWithoutTimelineInput
}

input UserUpdateOneWithoutPremiseInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPremiseInput
  create: UserCreateWithoutPremiseInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutPremiseInput
  upsert: UserUpsertWithoutPremiseInput
}

input UserUpdateOneWithoutVisionInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutVisionInput
  create: UserCreateWithoutVisionInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutVisionInput
  upsert: UserUpsertWithoutVisionInput
}

input UserUpdateWithoutPremiseInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  timeline: TimelineUpdateManyWithoutAuthorInput
  vision: VisionUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutTimelineInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  premise: PremiseUpdateManyWithoutAuthorInput
  role: EnumRoleFieldUpdateOperationsInput
  vision: VisionUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutVisionInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  premise: PremiseUpdateManyWithoutAuthorInput
  role: EnumRoleFieldUpdateOperationsInput
  timeline: TimelineUpdateManyWithoutAuthorInput
}

input UserUpsertWithoutPremiseInput {
  create: UserCreateWithoutPremiseInput!
  update: UserUpdateWithoutPremiseInput!
}

input UserUpsertWithoutTimelineInput {
  create: UserCreateWithoutTimelineInput!
  update: UserUpdateWithoutTimelineInput!
}

input UserUpsertWithoutVisionInput {
  create: UserCreateWithoutVisionInput!
  update: UserUpdateWithoutVisionInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  name: StringNullableFilter
  premise: PremiseListRelationFilter
  role: EnumRoleFilter
  timeline: TimelineListRelationFilter
  vision: VisionListRelationFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}

type Vision {
  _count: VisionCount
  activityDate: DateTime!
  author: User
  authorId: String
  createdAt: DateTime!
  description: String!
  id: String!
  nextVision(cursor: VisionWhereUniqueInput, distinct: [VisionScalarFieldEnum!], orderBy: [VisionOrderByWithRelationInput!], skip: Int, take: Int, where: VisionWhereInput): [Vision!]!
  premise: Premise!
  premiseId: String!
  prevVision: Vision
  prevVisionId: String
  reference: String!
  title: String!
}

type VisionCount {
  nextVision: Int!
}

type VisionCountAggregate {
  _all: Int!
  activityDate: Int!
  authorId: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  premiseId: Int!
  prevVisionId: Int!
  reference: Int!
  title: Int!
}

input VisionCountOrderByAggregateInput {
  activityDate: SortOrder
  authorId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  premiseId: SortOrder
  prevVisionId: SortOrder
  reference: SortOrder
  title: SortOrder
}

input VisionCreateInput {
  activityDate: DateTime!
  author: UserCreateNestedOneWithoutVisionInput
  createdAt: DateTime
  description: String!
  id: String
  nextVision: VisionCreateNestedManyWithoutPrevVisionInput
  premise: PremiseCreateNestedOneWithoutVisionInput!
  prevVision: VisionCreateNestedOneWithoutNextVisionInput
  reference: String!
  title: String!
}

input VisionCreateManyAuthorInput {
  activityDate: DateTime!
  createdAt: DateTime
  description: String!
  id: String
  premiseId: String!
  prevVisionId: String
  reference: String!
  title: String!
}

input VisionCreateManyAuthorInputEnvelope {
  data: [VisionCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input VisionCreateManyInput {
  activityDate: DateTime!
  authorId: String
  createdAt: DateTime
  description: String!
  id: String
  premiseId: String!
  prevVisionId: String
  reference: String!
  title: String!
}

input VisionCreateManyPremiseInput {
  activityDate: DateTime!
  authorId: String
  createdAt: DateTime
  description: String!
  id: String
  prevVisionId: String
  reference: String!
  title: String!
}

input VisionCreateManyPremiseInputEnvelope {
  data: [VisionCreateManyPremiseInput!]!
  skipDuplicates: Boolean
}

input VisionCreateManyPrevVisionInput {
  activityDate: DateTime!
  authorId: String
  createdAt: DateTime
  description: String!
  id: String
  premiseId: String!
  reference: String!
  title: String!
}

input VisionCreateManyPrevVisionInputEnvelope {
  data: [VisionCreateManyPrevVisionInput!]!
  skipDuplicates: Boolean
}

input VisionCreateNestedManyWithoutAuthorInput {
  connect: [VisionWhereUniqueInput!]
  connectOrCreate: [VisionCreateOrConnectWithoutAuthorInput!]
  create: [VisionCreateWithoutAuthorInput!]
  createMany: VisionCreateManyAuthorInputEnvelope
}

input VisionCreateNestedManyWithoutPremiseInput {
  connect: [VisionWhereUniqueInput!]
  connectOrCreate: [VisionCreateOrConnectWithoutPremiseInput!]
  create: [VisionCreateWithoutPremiseInput!]
  createMany: VisionCreateManyPremiseInputEnvelope
}

input VisionCreateNestedManyWithoutPrevVisionInput {
  connect: [VisionWhereUniqueInput!]
  connectOrCreate: [VisionCreateOrConnectWithoutPrevVisionInput!]
  create: [VisionCreateWithoutPrevVisionInput!]
  createMany: VisionCreateManyPrevVisionInputEnvelope
}

input VisionCreateNestedOneWithoutNextVisionInput {
  connect: VisionWhereUniqueInput
  connectOrCreate: VisionCreateOrConnectWithoutNextVisionInput
  create: VisionCreateWithoutNextVisionInput
}

input VisionCreateOrConnectWithoutAuthorInput {
  create: VisionCreateWithoutAuthorInput!
  where: VisionWhereUniqueInput!
}

input VisionCreateOrConnectWithoutNextVisionInput {
  create: VisionCreateWithoutNextVisionInput!
  where: VisionWhereUniqueInput!
}

input VisionCreateOrConnectWithoutPremiseInput {
  create: VisionCreateWithoutPremiseInput!
  where: VisionWhereUniqueInput!
}

input VisionCreateOrConnectWithoutPrevVisionInput {
  create: VisionCreateWithoutPrevVisionInput!
  where: VisionWhereUniqueInput!
}

input VisionCreateWithoutAuthorInput {
  activityDate: DateTime!
  createdAt: DateTime
  description: String!
  id: String
  nextVision: VisionCreateNestedManyWithoutPrevVisionInput
  premise: PremiseCreateNestedOneWithoutVisionInput!
  prevVision: VisionCreateNestedOneWithoutNextVisionInput
  reference: String!
  title: String!
}

input VisionCreateWithoutNextVisionInput {
  activityDate: DateTime!
  author: UserCreateNestedOneWithoutVisionInput
  createdAt: DateTime
  description: String!
  id: String
  premise: PremiseCreateNestedOneWithoutVisionInput!
  prevVision: VisionCreateNestedOneWithoutNextVisionInput
  reference: String!
  title: String!
}

input VisionCreateWithoutPremiseInput {
  activityDate: DateTime!
  author: UserCreateNestedOneWithoutVisionInput
  createdAt: DateTime
  description: String!
  id: String
  nextVision: VisionCreateNestedManyWithoutPrevVisionInput
  prevVision: VisionCreateNestedOneWithoutNextVisionInput
  reference: String!
  title: String!
}

input VisionCreateWithoutPrevVisionInput {
  activityDate: DateTime!
  author: UserCreateNestedOneWithoutVisionInput
  createdAt: DateTime
  description: String!
  id: String
  nextVision: VisionCreateNestedManyWithoutPrevVisionInput
  premise: PremiseCreateNestedOneWithoutVisionInput!
  reference: String!
  title: String!
}

type VisionGroupBy {
  _count: VisionCountAggregate
  _max: VisionMaxAggregate
  _min: VisionMinAggregate
  activityDate: DateTime!
  authorId: String
  createdAt: DateTime!
  description: String!
  id: String!
  premiseId: String!
  prevVisionId: String
  reference: String!
  title: String!
}

input VisionListRelationFilter {
  every: VisionWhereInput
  none: VisionWhereInput
  some: VisionWhereInput
}

type VisionMaxAggregate {
  activityDate: DateTime
  authorId: String
  createdAt: DateTime
  description: String
  id: String
  premiseId: String
  prevVisionId: String
  reference: String
  title: String
}

input VisionMaxOrderByAggregateInput {
  activityDate: SortOrder
  authorId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  premiseId: SortOrder
  prevVisionId: SortOrder
  reference: SortOrder
  title: SortOrder
}

type VisionMinAggregate {
  activityDate: DateTime
  authorId: String
  createdAt: DateTime
  description: String
  id: String
  premiseId: String
  prevVisionId: String
  reference: String
  title: String
}

input VisionMinOrderByAggregateInput {
  activityDate: SortOrder
  authorId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  premiseId: SortOrder
  prevVisionId: SortOrder
  reference: SortOrder
  title: SortOrder
}

input VisionOrderByRelationAggregateInput {
  _count: SortOrder
}

input VisionOrderByWithAggregationInput {
  _count: VisionCountOrderByAggregateInput
  _max: VisionMaxOrderByAggregateInput
  _min: VisionMinOrderByAggregateInput
  activityDate: SortOrder
  authorId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  premiseId: SortOrder
  prevVisionId: SortOrder
  reference: SortOrder
  title: SortOrder
}

input VisionOrderByWithRelationInput {
  activityDate: SortOrder
  author: UserOrderByWithRelationInput
  authorId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  nextVision: VisionOrderByRelationAggregateInput
  premise: PremiseOrderByWithRelationInput
  premiseId: SortOrder
  prevVision: VisionOrderByWithRelationInput
  prevVisionId: SortOrder
  reference: SortOrder
  title: SortOrder
}

input VisionRelationFilter {
  is: VisionWhereInput
  isNot: VisionWhereInput
}

enum VisionScalarFieldEnum {
  activityDate
  authorId
  createdAt
  description
  id
  premiseId
  prevVisionId
  reference
  title
}

input VisionScalarWhereInput {
  AND: [VisionScalarWhereInput!]
  NOT: [VisionScalarWhereInput!]
  OR: [VisionScalarWhereInput!]
  activityDate: DateTimeFilter
  authorId: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  premiseId: StringFilter
  prevVisionId: StringNullableFilter
  reference: StringFilter
  title: StringFilter
}

input VisionScalarWhereWithAggregatesInput {
  AND: [VisionScalarWhereWithAggregatesInput!]
  NOT: [VisionScalarWhereWithAggregatesInput!]
  OR: [VisionScalarWhereWithAggregatesInput!]
  activityDate: DateTimeWithAggregatesFilter
  authorId: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  premiseId: StringWithAggregatesFilter
  prevVisionId: StringNullableWithAggregatesFilter
  reference: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
}

input VisionUpdateInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  author: UserUpdateOneWithoutVisionInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  nextVision: VisionUpdateManyWithoutPrevVisionInput
  premise: PremiseUpdateOneRequiredWithoutVisionInput
  prevVision: VisionUpdateOneWithoutNextVisionInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input VisionUpdateManyMutationInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input VisionUpdateManyWithWhereWithoutAuthorInput {
  data: VisionUpdateManyMutationInput!
  where: VisionScalarWhereInput!
}

input VisionUpdateManyWithWhereWithoutPremiseInput {
  data: VisionUpdateManyMutationInput!
  where: VisionScalarWhereInput!
}

input VisionUpdateManyWithWhereWithoutPrevVisionInput {
  data: VisionUpdateManyMutationInput!
  where: VisionScalarWhereInput!
}

input VisionUpdateManyWithoutAuthorInput {
  connect: [VisionWhereUniqueInput!]
  connectOrCreate: [VisionCreateOrConnectWithoutAuthorInput!]
  create: [VisionCreateWithoutAuthorInput!]
  createMany: VisionCreateManyAuthorInputEnvelope
  delete: [VisionWhereUniqueInput!]
  deleteMany: [VisionScalarWhereInput!]
  disconnect: [VisionWhereUniqueInput!]
  set: [VisionWhereUniqueInput!]
  update: [VisionUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [VisionUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [VisionUpsertWithWhereUniqueWithoutAuthorInput!]
}

input VisionUpdateManyWithoutPremiseInput {
  connect: [VisionWhereUniqueInput!]
  connectOrCreate: [VisionCreateOrConnectWithoutPremiseInput!]
  create: [VisionCreateWithoutPremiseInput!]
  createMany: VisionCreateManyPremiseInputEnvelope
  delete: [VisionWhereUniqueInput!]
  deleteMany: [VisionScalarWhereInput!]
  disconnect: [VisionWhereUniqueInput!]
  set: [VisionWhereUniqueInput!]
  update: [VisionUpdateWithWhereUniqueWithoutPremiseInput!]
  updateMany: [VisionUpdateManyWithWhereWithoutPremiseInput!]
  upsert: [VisionUpsertWithWhereUniqueWithoutPremiseInput!]
}

input VisionUpdateManyWithoutPrevVisionInput {
  connect: [VisionWhereUniqueInput!]
  connectOrCreate: [VisionCreateOrConnectWithoutPrevVisionInput!]
  create: [VisionCreateWithoutPrevVisionInput!]
  createMany: VisionCreateManyPrevVisionInputEnvelope
  delete: [VisionWhereUniqueInput!]
  deleteMany: [VisionScalarWhereInput!]
  disconnect: [VisionWhereUniqueInput!]
  set: [VisionWhereUniqueInput!]
  update: [VisionUpdateWithWhereUniqueWithoutPrevVisionInput!]
  updateMany: [VisionUpdateManyWithWhereWithoutPrevVisionInput!]
  upsert: [VisionUpsertWithWhereUniqueWithoutPrevVisionInput!]
}

input VisionUpdateOneWithoutNextVisionInput {
  connect: VisionWhereUniqueInput
  connectOrCreate: VisionCreateOrConnectWithoutNextVisionInput
  create: VisionCreateWithoutNextVisionInput
  delete: Boolean
  disconnect: Boolean
  update: VisionUpdateWithoutNextVisionInput
  upsert: VisionUpsertWithoutNextVisionInput
}

input VisionUpdateWithWhereUniqueWithoutAuthorInput {
  data: VisionUpdateWithoutAuthorInput!
  where: VisionWhereUniqueInput!
}

input VisionUpdateWithWhereUniqueWithoutPremiseInput {
  data: VisionUpdateWithoutPremiseInput!
  where: VisionWhereUniqueInput!
}

input VisionUpdateWithWhereUniqueWithoutPrevVisionInput {
  data: VisionUpdateWithoutPrevVisionInput!
  where: VisionWhereUniqueInput!
}

input VisionUpdateWithoutAuthorInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  nextVision: VisionUpdateManyWithoutPrevVisionInput
  premise: PremiseUpdateOneRequiredWithoutVisionInput
  prevVision: VisionUpdateOneWithoutNextVisionInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input VisionUpdateWithoutNextVisionInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  author: UserUpdateOneWithoutVisionInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  premise: PremiseUpdateOneRequiredWithoutVisionInput
  prevVision: VisionUpdateOneWithoutNextVisionInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input VisionUpdateWithoutPremiseInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  author: UserUpdateOneWithoutVisionInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  nextVision: VisionUpdateManyWithoutPrevVisionInput
  prevVision: VisionUpdateOneWithoutNextVisionInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input VisionUpdateWithoutPrevVisionInput {
  activityDate: DateTimeFieldUpdateOperationsInput
  author: UserUpdateOneWithoutVisionInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  nextVision: VisionUpdateManyWithoutPrevVisionInput
  premise: PremiseUpdateOneRequiredWithoutVisionInput
  reference: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input VisionUpsertWithWhereUniqueWithoutAuthorInput {
  create: VisionCreateWithoutAuthorInput!
  update: VisionUpdateWithoutAuthorInput!
  where: VisionWhereUniqueInput!
}

input VisionUpsertWithWhereUniqueWithoutPremiseInput {
  create: VisionCreateWithoutPremiseInput!
  update: VisionUpdateWithoutPremiseInput!
  where: VisionWhereUniqueInput!
}

input VisionUpsertWithWhereUniqueWithoutPrevVisionInput {
  create: VisionCreateWithoutPrevVisionInput!
  update: VisionUpdateWithoutPrevVisionInput!
  where: VisionWhereUniqueInput!
}

input VisionUpsertWithoutNextVisionInput {
  create: VisionCreateWithoutNextVisionInput!
  update: VisionUpdateWithoutNextVisionInput!
}

input VisionWhereInput {
  AND: [VisionWhereInput!]
  NOT: [VisionWhereInput!]
  OR: [VisionWhereInput!]
  activityDate: DateTimeFilter
  author: UserRelationFilter
  authorId: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  nextVision: VisionListRelationFilter
  premise: PremiseRelationFilter
  premiseId: StringFilter
  prevVision: VisionRelationFilter
  prevVisionId: StringNullableFilter
  reference: StringFilter
  title: StringFilter
}

input VisionWhereUniqueInput {
  id: String
}
